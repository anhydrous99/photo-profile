---
phase: 07-public-gallery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/images/[photoId]/[filename]/route.ts
autonomous: true

must_haves:
  truths:
    - "Processed images are accessible via HTTP"
    - "Images have proper Content-Type headers"
    - "Images are cached with immutable headers"
  artifacts:
    - path: "src/app/api/images/[photoId]/[filename]/route.ts"
      provides: "Image serving endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/images/[photoId]/[filename]/route.ts"
      to: "storage/processed/{photoId}/{filename}"
      via: "fs.readFile"
      pattern: "readFile.*processed"
---

<objective>
Create API route to serve processed images from the storage directory.

Purpose: Images are stored outside /public (in storage/processed/), so they need an API route to serve them with proper headers. This enables responsive image loading with srcset.

Output: A GET endpoint at /api/images/[photoId]/[filename] that returns processed images with correct Content-Type and caching headers.
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-public-gallery/07-RESEARCH.md

@src/infrastructure/config/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create image serving API route</name>
  <files>src/app/api/images/[photoId]/[filename]/route.ts</files>
  <action>
Create a GET endpoint that serves processed images from storage.

Implementation details:

1. Use Next.js 16 async params pattern: `params: Promise<{ photoId: string; filename: string }>`
2. Await params at start of handler
3. Validate filename to prevent directory traversal (reject if contains ".." or "/")
4. Map file extensions to MIME types: .webp -> image/webp, .avif -> image/avif
5. Construct file path: `join(env.STORAGE_PATH, "processed", photoId, filename)`
6. Use fs/promises readFile + stat to get file and size
7. Return NextResponse with:
   - Content-Type header from extension mapping
   - Content-Length header from stat
   - Cache-Control: "public, max-age=31536000, immutable" (1 year, immutable)
8. Return 404 if file not found, 400 if invalid filename or unsupported extension

Import env from "@/infrastructure/config/env" for STORAGE_PATH.
</action>
<verify>
Test with curl:

```bash
# Assuming you have a processed photo with ID "test-id" and file "300w.webp"
curl -I http://localhost:3000/api/images/test-id/300w.webp
# Should return 200 with Content-Type: image/webp and Cache-Control headers

# Test 404 for non-existent photo
curl -I http://localhost:3000/api/images/nonexistent/300w.webp
# Should return 404

# Test 400 for traversal attempt
curl -I http://localhost:3000/api/images/test-id/../../../etc/passwd
# Should return 400
```

  </verify>
  <done>
- GET /api/images/[photoId]/[filename] returns processed images
- WebP and AVIF files served with correct Content-Type
- Cache-Control header set to 1 year immutable
- 404 returned for missing files
- 400 returned for invalid filenames
  </done>
</task>

</tasks>

<verification>
1. API route file exists at correct path
2. Route handles GET requests
3. Returns proper Content-Type for .webp and .avif files
4. Sets aggressive caching headers
5. Validates filename against traversal attacks
</verification>

<success_criteria>

- Processed images accessible at /api/images/{photoId}/{filename}
- Correct MIME types returned
- Browser caches images correctly (check Network tab)
  </success_criteria>

<output>
After completion, create `.planning/phases/07-public-gallery/07-01-SUMMARY.md`
</output>
