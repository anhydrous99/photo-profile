---
phase: 04-photo-upload
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - src/app/admin/(protected)/upload/page.tsx
  - src/app/admin/(protected)/page.tsx
  - src/presentation/components/UploadQueue.tsx
  - src/presentation/components/PhotoGrid.tsx
  - src/presentation/components/index.ts
autonomous: false

must_haves:
  truths:
    - "Admin can navigate to /admin/upload"
    - "Dropping files starts upload with progress display"
    - "Each file shows individual upload progress"
    - "Completed uploads show success state"
    - "Failed uploads show error message"
    - "Admin dashboard shows list of uploaded photos"
  artifacts:
    - path: "src/app/admin/(protected)/upload/page.tsx"
      provides: "Upload page with DropZone and queue"
      min_lines: 50
    - path: "src/presentation/components/UploadQueue.tsx"
      provides: "Upload queue showing per-file progress"
      exports: ["UploadQueue", "UploadItem"]
    - path: "src/presentation/components/PhotoGrid.tsx"
      provides: "Grid display of uploaded photos"
      exports: ["PhotoGrid"]
  key_links:
    - from: "src/app/admin/(protected)/upload/page.tsx"
      to: "src/presentation/components/DropZone.tsx"
      via: "component import"
      pattern: "DropZone"
    - from: "src/app/admin/(protected)/upload/page.tsx"
      to: "src/presentation/lib/uploadFile.ts"
      via: "uploadFile call"
      pattern: "uploadFile\\("
    - from: "src/app/admin/(protected)/page.tsx"
      to: "SQLitePhotoRepository"
      via: "repository.findAll()"
      pattern: "findAll\\(\\)"
---

<objective>
Create the upload page with batch upload state management and admin photo list

Purpose: Assemble the DropZone and uploadFile utilities into a complete upload experience. Manage batch upload state (pending, uploading, complete, error) with per-file progress. Update admin dashboard to show uploaded photos.

Output: Working upload flow at /admin/upload and photo list on admin dashboard
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-photo-upload/04-CONTEXT.md

# Prior plans created:

# - 04-01: /api/admin/upload endpoint

# - 04-02: DropZone component and uploadFile function

@src/presentation/components/DropZone.tsx
@src/presentation/lib/uploadFile.ts
@src/infrastructure/database/repositories/SQLitePhotoRepository.ts
@src/domain/entities/Photo.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UploadQueue component for batch progress display</name>
  <files>
    src/presentation/components/UploadQueue.tsx
    src/presentation/components/index.ts
  </files>
  <action>
**1. Create UploadQueue.tsx:**

```typescript
// src/presentation/components/UploadQueue.tsx
"use client";

/**
 * Status of a single upload item
 */
export type UploadStatus = "pending" | "uploading" | "complete" | "error";

/**
 * Single upload item in the queue
 */
export interface UploadItem {
  id: string;
  file: File;
  status: UploadStatus;
  progress: number;
  photoId?: string;
  error?: string;
}

interface UploadQueueProps {
  items: UploadItem[];
  onRetry?: (id: string) => void;
}

/**
 * Display upload queue with per-file progress
 *
 * Shows each file with:
 * - Filename
 * - Progress bar (during upload)
 * - Success indicator (after complete)
 * - Error message with retry (on failure)
 */
export function UploadQueue({ items, onRetry }: UploadQueueProps) {
  if (items.length === 0) {
    return null;
  }

  return (
    <div className="mt-8 space-y-3">
      <h2 className="text-lg font-medium text-gray-700">Upload Queue</h2>
      <div className="space-y-2">
        {items.map((item) => (
          <UploadItemRow key={item.id} item={item} onRetry={onRetry} />
        ))}
      </div>
    </div>
  );
}

function UploadItemRow({
  item,
  onRetry,
}: {
  item: UploadItem;
  onRetry?: (id: string) => void;
}) {
  return (
    <div className="flex items-center gap-4 rounded-lg border border-gray-200 bg-white p-3">
      {/* Filename */}
      <div className="min-w-0 flex-1">
        <p className="truncate text-sm font-medium text-gray-700">
          {item.file.name}
        </p>
        <p className="text-xs text-gray-400">
          {formatFileSize(item.file.size)}
        </p>
      </div>

      {/* Status indicator */}
      <div className="w-32">
        {item.status === "pending" && (
          <span className="text-sm text-gray-400">Waiting...</span>
        )}

        {item.status === "uploading" && (
          <div className="space-y-1">
            <div className="h-2 overflow-hidden rounded-full bg-gray-200">
              <div
                className="h-full bg-blue-500 transition-all duration-200"
                style={{ width: `${item.progress}%` }}
              />
            </div>
            <span className="text-xs text-gray-500">{item.progress}%</span>
          </div>
        )}

        {item.status === "complete" && (
          <span className="text-sm font-medium text-green-600">Complete</span>
        )}

        {item.status === "error" && (
          <div className="flex items-center gap-2">
            <span className="text-sm text-red-600">Failed</span>
            {onRetry && (
              <button
                onClick={() => onRetry(item.id)}
                className="text-xs text-blue-600 hover:underline"
              >
                Retry
              </button>
            )}
          </div>
        )}
      </div>
    </div>
  );
}

function formatFileSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}
```

**2. Update barrel export:**

Add UploadQueue export to src/presentation/components/index.ts:

```typescript
export { DropZone } from "./DropZone";
export { UploadQueue } from "./UploadQueue";
export type { UploadItem, UploadStatus } from "./UploadQueue";
```

Key implementation details:

- UploadItem type tracks status, progress, photoId, and error per file
- Progress bar shows during "uploading" status
- Error state includes optional retry button
- File size formatted for readability
  </action>
  <verify>

1. Run `npm run lint` - no errors
2. Check file exists: `ls src/presentation/components/UploadQueue.tsx`
   </verify>
   <done>

- UploadQueue component displays per-file upload status
- Shows progress bar, success, error states
- Exports UploadItem type for state management
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create upload page with batch state management</name>
  <files>src/app/admin/(protected)/upload/page.tsx</files>
  <action>
Create the upload page that orchestrates the entire upload flow:

```typescript
// src/app/admin/(protected)/upload/page.tsx
"use client";

import { useState, useCallback } from "react";
import { DropZone, UploadQueue } from "@/presentation/components";
import type { UploadItem } from "@/presentation/components";
import { uploadFile } from "@/presentation/lib";
import Link from "next/link";

/**
 * Admin Upload Page
 *
 * Orchestrates the batch upload flow:
 * 1. User drops files onto DropZone
 * 2. Files added to upload queue
 * 3. Uploads processed sequentially (2 concurrent max)
 * 4. Progress tracked per file
 * 5. Success/error states displayed
 */
export default function UploadPage() {
  const [items, setItems] = useState<UploadItem[]>([]);
  const [isUploading, setIsUploading] = useState(false);

  // Handle files dropped onto zone
  const handleFilesAccepted = useCallback(
    async (files: File[]) => {
      // Create upload items for each file
      const newItems: UploadItem[] = files.map((file) => ({
        id: crypto.randomUUID(),
        file,
        status: "pending" as const,
        progress: 0,
      }));

      setItems((prev) => [...prev, ...newItems]);

      // Start processing if not already uploading
      if (!isUploading) {
        processQueue([...items, ...newItems]);
      }
    },
    [items, isUploading],
  );

  // Process upload queue with controlled concurrency
  const processQueue = async (queue: UploadItem[]) => {
    setIsUploading(true);

    // Process files sequentially for simplicity
    // (Could add concurrency: 2 if needed)
    for (const item of queue) {
      if (item.status !== "pending") continue;

      // Update to uploading
      setItems((prev) =>
        prev.map((i) =>
          i.id === item.id ? { ...i, status: "uploading" as const } : i,
        ),
      );

      try {
        const controller = uploadFile(item.file, (progress) => {
          setItems((prev) =>
            prev.map((i) => (i.id === item.id ? { ...i, progress } : i)),
          );
        });

        const result = await controller.promise;

        // Update to complete
        setItems((prev) =>
          prev.map((i) =>
            i.id === item.id
              ? { ...i, status: "complete" as const, photoId: result.photoId }
              : i,
          ),
        );
      } catch (error) {
        // Update to error
        setItems((prev) =>
          prev.map((i) =>
            i.id === item.id
              ? {
                  ...i,
                  status: "error" as const,
                  error: error instanceof Error ? error.message : "Upload failed",
                }
              : i,
          ),
        );
      }
    }

    setIsUploading(false);
  };

  // Retry a failed upload
  const handleRetry = useCallback(
    (id: string) => {
      setItems((prev) =>
        prev.map((i) =>
          i.id === id ? { ...i, status: "pending" as const, progress: 0 } : i,
        ),
      );

      // Restart queue processing
      const itemToRetry = items.find((i) => i.id === id);
      if (itemToRetry && !isUploading) {
        processQueue([{ ...itemToRetry, status: "pending", progress: 0 }]);
      }
    },
    [items, isUploading],
  );

  // Count stats
  const stats = {
    total: items.length,
    complete: items.filter((i) => i.status === "complete").length,
    failed: items.filter((i) => i.status === "error").length,
  };

  return (
    <div className="mx-auto max-w-3xl p-8">
      <div className="mb-6 flex items-center justify-between">
        <h1 className="text-2xl font-bold">Upload Photos</h1>
        <Link
          href="/admin"
          className="text-sm text-gray-500 hover:text-gray-700"
        >
          Back to Dashboard
        </Link>
      </div>

      <DropZone
        onFilesAccepted={handleFilesAccepted}
        disabled={isUploading}
      />

      <UploadQueue items={items} onRetry={handleRetry} />

      {stats.total > 0 && (
        <div className="mt-4 text-sm text-gray-500">
          {stats.complete} of {stats.total} uploaded
          {stats.failed > 0 && ` (${stats.failed} failed)`}
        </div>
      )}
    </div>
  );
}
```

Key implementation details:

- Uses useState for upload queue management
- Processes uploads sequentially (simple, reliable)
- Progress updates via uploadFile callback
- Retry functionality for failed uploads
- DropZone disabled during upload to prevent confusion
- Back link to dashboard for navigation
  </action>
  <verify>

1. Run `npm run lint` - no errors
2. Check file exists: `ls src/app/admin/(protected)/upload/page.tsx`
   </verify>
   <done>

- Upload page at /admin/upload with DropZone and UploadQueue
- Batch upload with per-file progress tracking
- Retry functionality for failed uploads
  </done>
  </task>

<task type="auto">
  <name>Task 3: Create PhotoGrid component and update admin dashboard</name>
  <files>
    src/presentation/components/PhotoGrid.tsx
    src/presentation/components/index.ts
    src/app/admin/(protected)/page.tsx
  </files>
  <action>
**1. Create PhotoGrid.tsx:**

```typescript
// src/presentation/components/PhotoGrid.tsx
import type { Photo } from "@/domain/entities";
import Link from "next/link";

interface PhotoGridProps {
  photos: Photo[];
}

/**
 * Display grid of photo cards
 *
 * Shows each photo with:
 * - Filename
 * - Status badge
 * - Created date
 */
export function PhotoGrid({ photos }: PhotoGridProps) {
  if (photos.length === 0) {
    return (
      <div className="rounded-lg border border-dashed border-gray-300 p-12 text-center">
        <p className="text-gray-500">No photos uploaded yet.</p>
        <Link
          href="/admin/upload"
          className="mt-2 inline-block text-blue-600 hover:underline"
        >
          Upload your first photo
        </Link>
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
      {photos.map((photo) => (
        <PhotoCard key={photo.id} photo={photo} />
      ))}
    </div>
  );
}

function PhotoCard({ photo }: { photo: Photo }) {
  return (
    <div className="overflow-hidden rounded-lg border border-gray-200 bg-white">
      {/* Placeholder for thumbnail - will be added in Phase 7 */}
      <div className="flex h-32 items-center justify-center bg-gray-100">
        <span className="text-sm text-gray-400">
          {photo.status === "processing" ? "Processing..." : "No preview"}
        </span>
      </div>

      <div className="p-3">
        <p className="truncate text-sm font-medium text-gray-700">
          {photo.originalFilename}
        </p>
        <div className="mt-1 flex items-center justify-between">
          <StatusBadge status={photo.status} />
          <span className="text-xs text-gray-400">
            {formatDate(photo.createdAt)}
          </span>
        </div>
      </div>
    </div>
  );
}

function StatusBadge({ status }: { status: Photo["status"] }) {
  const styles = {
    processing: "bg-yellow-100 text-yellow-800",
    ready: "bg-green-100 text-green-800",
    error: "bg-red-100 text-red-800",
  };

  return (
    <span
      className={`rounded-full px-2 py-0.5 text-xs font-medium ${styles[status]}`}
    >
      {status}
    </span>
  );
}

function formatDate(date: Date): string {
  return new Intl.DateTimeFormat("en-US", {
    month: "short",
    day: "numeric",
  }).format(date);
}
```

**2. Update barrel export:**

Add PhotoGrid export to src/presentation/components/index.ts:

```typescript
export { DropZone } from "./DropZone";
export { UploadQueue } from "./UploadQueue";
export type { UploadItem, UploadStatus } from "./UploadQueue";
export { PhotoGrid } from "./PhotoGrid";
```

**3. Update admin dashboard:**

```typescript
// src/app/admin/(protected)/page.tsx
import Link from "next/link";
import { SQLitePhotoRepository } from "@/infrastructure/database/repositories";
import { PhotoGrid } from "@/presentation/components";

const photoRepository = new SQLitePhotoRepository();

/**
 * Admin Dashboard
 *
 * Shows:
 * - Link to upload page
 * - Grid of uploaded photos
 */
export default async function AdminDashboard() {
  const photos = await photoRepository.findAll();

  // Sort by newest first
  const sortedPhotos = [...photos].sort(
    (a, b) => b.createdAt.getTime() - a.createdAt.getTime(),
  );

  return (
    <div className="p-8">
      <div className="mb-6 flex items-center justify-between">
        <h1 className="text-2xl font-bold">Admin Dashboard</h1>
        <Link
          href="/admin/upload"
          className="rounded-lg bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700"
        >
          Upload Photos
        </Link>
      </div>

      <h2 className="mb-4 text-lg font-medium text-gray-700">
        Photos ({photos.length})
      </h2>

      <PhotoGrid photos={sortedPhotos} />
    </div>
  );
}
```

Key implementation details:

- PhotoGrid is a Server Component (no "use client")
- Admin dashboard fetches photos from repository
- Photos sorted by newest first
- Empty state links to upload page
- Status badge shows processing/ready/error
- Placeholder for thumbnails (Phase 7 will add actual images)
  </action>
  <verify>

1. Run `npm run lint` - no errors
2. Run `npm run build` - compiles successfully
3. Check files exist:
   - `ls src/presentation/components/PhotoGrid.tsx`
   - `ls src/app/admin/(protected)/upload/page.tsx`
     </verify>
     <done>

- PhotoGrid component displays uploaded photos with status
- Admin dashboard at /admin shows photo list
- Upload link prominently displayed
  </done>
  </task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete upload flow: drag-drop interface, batch upload with progress, and photo list on dashboard
  </what-built>
  <how-to-verify>
**Prerequisites:** Ensure dev server and Redis are running. If Redis unavailable, uploads will work but processing jobs will fail (expected - Docker not installed).

1. Start the dev server: `npm run dev`
2. Log in at http://localhost:3000/admin/login
3. Navigate to http://localhost:3000/admin/upload
4. Verify the large drag-drop zone is visible with "Drag and drop photos here" text
5. Drag 2-3 image files onto the drop zone (JPEG/PNG)
6. Verify:
   - Files appear in the upload queue below the drop zone
   - Progress bar shows for each file during upload
   - Each file shows "Complete" status when done
   - Summary shows "X of Y uploaded"
7. Click "Back to Dashboard" link
8. Verify the uploaded photos appear in the photo grid with:
   - Filename displayed
   - "processing" status badge (changes to "ready" after pipeline completes)
   - Upload date shown

**Expected without Redis running:**

- Upload completes successfully (file saved, DB record created)
- Photo shows "processing" status indefinitely (job queue not running)
- No errors in browser console related to the upload itself
  </how-to-verify>
  <resume-signal>Type "approved" if upload flow works, or describe any issues</resume-signal>
  </task>

</tasks>

<verification>
After all tasks complete:

1. **Lint:** `npm run lint` passes
2. **Build:** `npm run build` succeeds
3. **Files exist:**
   - src/app/admin/(protected)/upload/page.tsx
   - src/presentation/components/UploadQueue.tsx
   - src/presentation/components/PhotoGrid.tsx
4. **Manual test:** Upload flow works end-to-end (verified by checkpoint)
   </verification>

<success_criteria>

- /admin/upload page shows large drag-drop zone
- Dropping multiple files queues them for upload
- Each file shows individual progress during upload
- Completed uploads show success state
- Failed uploads show error with retry option
- Admin dashboard shows grid of uploaded photos
- Photos display filename, status badge, and date
  </success_criteria>

<output>
After completion, create `.planning/phases/04-photo-upload/04-03-SUMMARY.md`
</output>
