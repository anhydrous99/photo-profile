---
phase: 04-photo-upload
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/presentation/components/DropZone.tsx
  - src/presentation/components/index.ts
  - src/presentation/lib/uploadFile.ts
  - src/presentation/lib/index.ts
autonomous: true

must_haves:
  truths:
    - "DropZone component renders a drag-drop target area"
    - "DropZone accepts JPEG, PNG, WebP, HEIC images"
    - "DropZone calls onFilesAccepted callback with File array"
    - "uploadFile function returns progress percentage during upload"
    - "uploadFile function returns photoId on success"
  artifacts:
    - path: "src/presentation/components/DropZone.tsx"
      provides: "Reusable drag-drop file zone component"
      exports: ["DropZone"]
    - path: "src/presentation/lib/uploadFile.ts"
      provides: "XHR upload with progress callback"
      exports: ["uploadFile", "UploadResult"]
  key_links:
    - from: "src/presentation/components/DropZone.tsx"
      to: "react-dropzone"
      via: "useDropzone hook"
      pattern: "useDropzone"
    - from: "src/presentation/lib/uploadFile.ts"
      to: "/api/admin/upload"
      via: "XHR POST request"
      pattern: "/api/admin/upload"
---

<objective>
Create the client-side upload components: DropZone UI and upload function with progress

Purpose: Build the reusable presentation layer components for file upload. The DropZone provides the drag-drop interaction, while uploadFile handles the actual HTTP upload with progress tracking via XMLHttpRequest (fetch API lacks upload progress support).

Output: Two presentation layer modules that can be composed in the upload page
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-photo-upload/04-RESEARCH.md
@.planning/phases/04-photo-upload/04-CONTEXT.md

# Prior plan created the upload endpoint

# (Do NOT read SUMMARY - just need to know endpoint exists at /api/admin/upload)

</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DropZone component</name>
  <files>
    src/presentation/components/DropZone.tsx
    src/presentation/components/index.ts
  </files>
  <action>
**1. Create DropZone.tsx:**

```typescript
// src/presentation/components/DropZone.tsx
"use client";

import { useCallback } from "react";
import { useDropzone, FileRejection } from "react-dropzone";

interface DropZoneProps {
  onFilesAccepted: (files: File[]) => void;
  onFilesRejected?: (rejections: FileRejection[]) => void;
  maxFiles?: number;
  maxSize?: number;
  disabled?: boolean;
}

/**
 * Drag-and-drop file upload zone
 *
 * Large, prominent drop target following the "photos speak for themselves"
 * design philosophy. Minimal visual states: idle and active (dragging).
 *
 * @param onFilesAccepted - Called with accepted File array
 * @param onFilesRejected - Called with rejected files (wrong type/size)
 * @param maxFiles - Maximum files per drop (default: 20)
 * @param maxSize - Maximum file size in bytes (default: 100MB)
 * @param disabled - Disable interaction during upload
 */
export function DropZone({
  onFilesAccepted,
  onFilesRejected,
  maxFiles = 20,
  maxSize = 100 * 1024 * 1024,
  disabled = false,
}: DropZoneProps) {
  const onDrop = useCallback(
    (acceptedFiles: File[], rejections: FileRejection[]) => {
      if (rejections.length > 0 && onFilesRejected) {
        onFilesRejected(rejections);
      }
      if (acceptedFiles.length > 0) {
        onFilesAccepted(acceptedFiles);
      }
    },
    [onFilesAccepted, onFilesRejected],
  );

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      "image/jpeg": [".jpg", ".jpeg"],
      "image/png": [".png"],
      "image/webp": [".webp"],
      "image/heic": [".heic"],
    },
    maxFiles,
    maxSize,
    disabled,
  });

  return (
    <div
      {...getRootProps()}
      className={`
        flex min-h-[400px] cursor-pointer flex-col items-center justify-center
        rounded-lg border-2 border-dashed p-12 text-center
        transition-colors duration-200
        ${disabled ? "cursor-not-allowed opacity-50" : ""}
        ${
          isDragActive
            ? "border-blue-500 bg-blue-50"
            : "border-gray-300 hover:border-gray-400"
        }
      `}
    >
      <input {...getInputProps()} />
      {isDragActive ? (
        <p className="text-xl text-blue-600">Drop photos here...</p>
      ) : (
        <>
          <p className="text-xl text-gray-600">
            Drag and drop photos here
          </p>
          <p className="mt-2 text-sm text-gray-400">
            or click to select files
          </p>
          <p className="mt-4 text-xs text-gray-400">
            JPEG, PNG, WebP, HEIC up to 100MB each
          </p>
        </>
      )}
    </div>
  );
}
```

**2. Create or update barrel export:**

```typescript
// src/presentation/components/index.ts
export { DropZone } from "./DropZone";
```

Key implementation details:

- Uses react-dropzone useDropzone hook for reliable cross-browser drag-drop
- Accepts JPEG, PNG, WebP, HEIC (matches server validation)
- Large centered drop zone (min-h-[400px]) per CONTEXT.md decision
- Minimal visual states: idle border-gray-300, active border-blue-500
- Disabled state for when upload is in progress
- Click-to-browse fallback included (getInputProps)
  </action>
  <verify>

1. Run `npm run lint` - no errors
2. Check file exists: `ls src/presentation/components/DropZone.tsx`
   </verify>
   <done>

- DropZone component exists with drag-drop functionality
- Component accepts onFilesAccepted and onFilesRejected callbacks
- Accepts image file types: JPEG, PNG, WebP, HEIC
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create upload function with progress tracking</name>
  <files>
    src/presentation/lib/uploadFile.ts
    src/presentation/lib/index.ts
  </files>
  <action>
**1. Create uploadFile.ts:**

```typescript
// src/presentation/lib/uploadFile.ts

/**
 * Result from successful upload
 */
export interface UploadResult {
  photoId: string;
  status: "processing";
}

/**
 * Upload error with message
 */
export interface UploadError {
  error: string;
}

/**
 * Controller returned from uploadFile for abort capability
 */
export interface UploadController {
  /** Abort the in-progress upload */
  abort: () => void;
  /** Promise that resolves with upload result or rejects on error */
  promise: Promise<UploadResult>;
}

/**
 * Upload a file to the server with progress tracking
 *
 * Uses XMLHttpRequest instead of fetch because fetch API doesn't
 * support upload progress events (Interop 2026 proposal still pending).
 *
 * @param file - The File to upload
 * @param onProgress - Callback with upload percentage (0-100)
 * @returns Controller with abort() and promise
 */
export function uploadFile(
  file: File,
  onProgress: (percent: number) => void,
): UploadController {
  const xhr = new XMLHttpRequest();

  const promise = new Promise<UploadResult>((resolve, reject) => {
    const formData = new FormData();
    formData.append("file", file);

    // Track upload progress
    xhr.upload.addEventListener("progress", (event) => {
      if (event.lengthComputable) {
        const percent = Math.round((event.loaded / event.total) * 100);
        onProgress(percent);
      }
    });

    // Handle completion
    xhr.addEventListener("load", () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        try {
          const result = JSON.parse(xhr.responseText) as UploadResult;
          resolve(result);
        } catch {
          reject(new Error("Invalid response from server"));
        }
      } else {
        try {
          const error = JSON.parse(xhr.responseText) as UploadError;
          reject(new Error(error.error || `Upload failed: ${xhr.status}`));
        } catch {
          reject(new Error(`Upload failed: ${xhr.status}`));
        }
      }
    });

    // Handle network errors
    xhr.addEventListener("error", () => {
      reject(new Error("Network error during upload"));
    });

    // Handle user abort
    xhr.addEventListener("abort", () => {
      reject(new Error("Upload cancelled"));
    });

    // Send request
    xhr.open("POST", "/api/admin/upload");
    xhr.send(formData);
  });

  return {
    abort: () => xhr.abort(),
    promise,
  };
}
```

**2. Create barrel export:**

```typescript
// src/presentation/lib/index.ts
export { uploadFile } from "./uploadFile";
export type { UploadResult, UploadError, UploadController } from "./uploadFile";
```

Key implementation details:

- Uses XMLHttpRequest for upload.onprogress events (fetch lacks this)
- Returns UploadController with abort capability for cancellation
- Parses JSON response, handles both success and error formats
- Progress callback receives 0-100 percentage
- Properly handles network errors vs HTTP errors vs abort
  </action>
  <verify>

1. Run `npm run lint` - no errors
2. Run `npm run build` - compiles successfully
3. Check file exists: `ls src/presentation/lib/uploadFile.ts`
   </verify>
   <done>

- uploadFile function exists with XHR-based progress tracking
- Returns UploadController with abort() and promise
- onProgress callback receives 0-100 percentage during upload
  </done>
  </task>

</tasks>

<verification>
After both tasks complete:

1. **Lint:** `npm run lint` passes
2. **Build:** `npm run build` succeeds
3. **Files exist:**
   - src/presentation/components/DropZone.tsx
   - src/presentation/components/index.ts
   - src/presentation/lib/uploadFile.ts
   - src/presentation/lib/index.ts
     </verification>

<success_criteria>

- DropZone component renders drag-drop target with JPEG/PNG/WebP/HEIC support
- DropZone calls onFilesAccepted callback when files dropped
- uploadFile function uploads to /api/admin/upload
- uploadFile provides progress percentage via callback
- uploadFile returns photoId on success
  </success_criteria>

<output>
After completion, create `.planning/phases/04-photo-upload/04-02-SUMMARY.md`
</output>
