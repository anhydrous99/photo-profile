---
phase: 04-photo-upload
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/app/api/admin/upload/route.ts
  - src/infrastructure/storage/fileStorage.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/admin/upload accepts multipart form data"
    - "Unauthenticated requests return 401"
    - "File is saved to storage/originals/{photoId}/"
    - "Photo record created in database with status 'processing'"
    - "Image processing job enqueued to BullMQ"
  artifacts:
    - path: "src/app/api/admin/upload/route.ts"
      provides: "Upload endpoint with auth, file save, DB record, job enqueue"
      exports: ["POST"]
    - path: "src/infrastructure/storage/fileStorage.ts"
      provides: "File write utilities for upload storage"
      exports: ["saveOriginalFile"]
  key_links:
    - from: "src/app/api/admin/upload/route.ts"
      to: "src/infrastructure/auth/dal.ts"
      via: "verifySession() call"
      pattern: "verifySession\\(\\)"
    - from: "src/app/api/admin/upload/route.ts"
      to: "src/infrastructure/jobs/queues.ts"
      via: "enqueueImageProcessing() call"
      pattern: "enqueueImageProcessing\\("
    - from: "src/app/api/admin/upload/route.ts"
      to: "SQLitePhotoRepository"
      via: "repository.save() call"
      pattern: "\\.save\\("
---

<objective>
Create the upload infrastructure: Route Handler endpoint and file storage utilities

Purpose: Establish the server-side foundation for receiving uploaded photos. The Route Handler validates auth, saves files to disk, creates database records, and triggers the image processing pipeline from Phase 2.

Output: Working upload API endpoint that accepts files and integrates with existing infrastructure
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-photo-upload/04-RESEARCH.md

# Existing infrastructure to integrate with

@src/infrastructure/auth/dal.ts
@src/infrastructure/jobs/queues.ts
@src/infrastructure/database/repositories/SQLitePhotoRepository.ts
@src/domain/entities/Photo.ts
@src/infrastructure/config/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-dropzone dependency</name>
  <files>package.json</files>
  <action>
Install react-dropzone v14.4.0 for the drag-drop UI component.

```bash
npm install react-dropzone
```

This is the only new dependency needed for the upload feature. The existing infrastructure (Sharp, BullMQ, ioredis) from Phase 2 handles image processing.
</action>
<verify>
Run `npm ls react-dropzone` - should show react-dropzone@14.4.0 (or compatible version)
</verify>
<done>react-dropzone appears in package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create file storage utility and upload Route Handler</name>
  <files>
    src/infrastructure/storage/fileStorage.ts
    src/infrastructure/storage/index.ts
    src/app/api/admin/upload/route.ts
  </files>
  <action>
**1. Create fileStorage.ts:**

```typescript
// src/infrastructure/storage/fileStorage.ts
import { mkdir, writeFile } from "fs/promises";
import { join, extname } from "path";
import { env } from "@/infrastructure/config/env";

/**
 * Save an uploaded file to the originals storage directory
 *
 * Directory structure: storage/originals/{photoId}/original.{ext}
 *
 * @param photoId - Unique identifier for the photo
 * @param file - The uploaded File object
 * @returns Full path to the saved file
 */
export async function saveOriginalFile(
  photoId: string,
  file: File,
): Promise<string> {
  const ext = extname(file.name).toLowerCase() || ".jpg";
  const dir = join(env.STORAGE_PATH, "originals", photoId);
  const filePath = join(dir, `original${ext}`);

  await mkdir(dir, { recursive: true });

  const bytes = await file.arrayBuffer();
  await writeFile(filePath, Buffer.from(bytes));

  return filePath;
}
```

**2. Create barrel export:**

```typescript
// src/infrastructure/storage/index.ts
export { saveOriginalFile } from "./fileStorage";
```

**3. Create Route Handler:**

```typescript
// src/app/api/admin/upload/route.ts
import { NextRequest, NextResponse } from "next/server";
import { verifySession } from "@/infrastructure/auth";
import { saveOriginalFile } from "@/infrastructure/storage";
import { enqueueImageProcessing } from "@/infrastructure/jobs";
import { SQLitePhotoRepository } from "@/infrastructure/database/repositories";
import type { Photo } from "@/domain/entities";

const photoRepository = new SQLitePhotoRepository();

/**
 * POST /api/admin/upload
 *
 * Handles single file upload:
 * 1. Verifies admin session
 * 2. Extracts file from multipart form data
 * 3. Generates unique photo ID
 * 4. Saves file to storage/originals/{photoId}/
 * 5. Creates photo record with status "processing"
 * 6. Enqueues image processing job
 *
 * Returns: { photoId, status: "processing" }
 */
export async function POST(request: NextRequest) {
  // 1. Verify session
  const session = await verifySession();
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  // 2. Parse form data
  const formData = await request.formData();
  const file = formData.get("file") as File | null;

  if (!file) {
    return NextResponse.json({ error: "No file provided" }, { status: 400 });
  }

  // Validate file type
  const allowedTypes = ["image/jpeg", "image/png", "image/webp", "image/heic"];
  if (!allowedTypes.includes(file.type)) {
    return NextResponse.json(
      {
        error: `Invalid file type: ${file.type}. Allowed: JPEG, PNG, WebP, HEIC`,
      },
      { status: 400 },
    );
  }

  // 3. Generate photo ID
  const photoId = crypto.randomUUID();

  // 4. Save file to disk
  const filePath = await saveOriginalFile(photoId, file);

  // 5. Create photo record
  const now = new Date();
  const photo: Photo = {
    id: photoId,
    title: null,
    description: null,
    originalFilename: file.name,
    status: "processing",
    createdAt: now,
    updatedAt: now,
  };
  await photoRepository.save(photo);

  // 6. Enqueue processing job
  await enqueueImageProcessing(photoId, filePath);

  return NextResponse.json({ photoId, status: "processing" }, { status: 201 });
}
```

Key implementation details:

- Uses verifySession() from existing auth DAL (not cookies directly)
- Uses crypto.randomUUID() (native, no external package)
- Validates MIME type before saving (JPEG, PNG, WebP, HEIC)
- Creates Photo record with status: "processing" per entity definition
- Triggers existing BullMQ pipeline via enqueueImageProcessing()
  </action>
  <verify>

1. Run `npm run lint` - no errors
2. Run `npm run build` - compiles successfully
3. Check file exists: `ls src/app/api/admin/upload/route.ts`
4. Check file exists: `ls src/infrastructure/storage/fileStorage.ts`
   </verify>
   <done>

- Route Handler exists at /api/admin/upload
- File storage utility saves to storage/originals/{photoId}/
- Route integrates with auth, database, and job queue
  </done>
  </task>

</tasks>

<verification>
After both tasks complete:

1. **Dependencies:** `npm ls react-dropzone` shows installed
2. **Lint:** `npm run lint` passes
3. **Build:** `npm run build` succeeds
4. **Files exist:**
   - src/app/api/admin/upload/route.ts
   - src/infrastructure/storage/fileStorage.ts
   - src/infrastructure/storage/index.ts
     </verification>

<success_criteria>

- react-dropzone installed in package.json
- Upload endpoint at /api/admin/upload accepts POST with file
- Endpoint requires authentication (401 without session)
- File saved to storage/originals/{photoId}/ directory
- Photo record created in SQLite with status "processing"
- Image processing job enqueued to BullMQ
  </success_criteria>

<output>
After completion, create `.planning/phases/04-photo-upload/04-01-SUMMARY.md`
</output>
