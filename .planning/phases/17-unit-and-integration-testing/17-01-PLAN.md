---
phase: 17-unit-and-integration-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/infrastructure/database/__tests__/photo-repository.test.ts
  - src/infrastructure/database/__tests__/album-repository.test.ts
autonomous: true

must_haves:
  truths:
    - "Photo repository CRUD operations (save, findById, findAll, delete) work correctly against in-memory SQLite"
    - "Album repository CRUD operations (save, findById, findAll, findPublished, delete) work correctly against in-memory SQLite"
    - "Photo-album junction operations (addToAlbum, removeFromAlbum, getAlbumIds, findByAlbumId, updatePhotoSortOrders) work correctly"
    - "Album junction operations (getPhotoCounts, updateSortOrders, deleteWithPhotos) work correctly"
    - "Round-trip serialization handles edge cases: null EXIF, corrupt JSON EXIF, Unicode filenames, zero dimensions, boolean isPublished"
  artifacts:
    - path: "src/infrastructure/database/__tests__/photo-repository.test.ts"
      provides: "Photo repository integration tests"
      min_lines: 150
    - path: "src/infrastructure/database/__tests__/album-repository.test.ts"
      provides: "Album repository integration tests"
      min_lines: 120
  key_links:
    - from: "src/infrastructure/database/__tests__/photo-repository.test.ts"
      to: "@/infrastructure/database/client"
      via: "vi.mock with lazy getter injecting test DB"
      pattern: "vi\\.mock.*database/client"
    - from: "src/infrastructure/database/__tests__/album-repository.test.ts"
      to: "@/infrastructure/database/client"
      via: "vi.mock with lazy getter injecting test DB"
      pattern: "vi\\.mock.*database/client"
---

<objective>
Write comprehensive repository integration tests for SQLitePhotoRepository and SQLiteAlbumRepository, covering full CRUD lifecycles, junction table operations, and toDomain/toDatabase round-trip serialization edge cases.

Purpose: Satisfies UNIT-01 (repository CRUD tests) and UNIT-02 (serialization edge cases) from the phase requirements. These are integration tests that run real SQL against in-memory SQLite via the createTestDb() helper from Phase 15.

Output: Two test files with passing assertions covering all repository methods and serialization edge cases.
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-testing-infrastructure/15-01-SUMMARY.md
@.planning/phases/15-testing-infrastructure/15-02-SUMMARY.md
@.planning/phases/17-unit-and-integration-testing/17-RESEARCH.md

# Source files to test

@src/infrastructure/database/repositories/SQLitePhotoRepository.ts
@src/infrastructure/database/repositories/SQLiteAlbumRepository.ts
@src/domain/entities/Photo.ts
@src/domain/entities/Album.ts

# Test infrastructure

@src/**tests**/helpers/test-db.ts
@src/**tests**/setup.ts
@vitest.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write SQLitePhotoRepository integration tests</name>
  <files>src/infrastructure/database/__tests__/photo-repository.test.ts</files>
  <action>
Create `src/infrastructure/database/__tests__/photo-repository.test.ts` with the following test structure:

**Setup pattern (CRITICAL -- use lazy getter for db mock):**

```typescript
import { createTestDb } from "@/__tests__/helpers/test-db";
import type Database from "better-sqlite3";
import type { BetterSQLite3Database } from "drizzle-orm/better-sqlite3";
import * as schema from "@/infrastructure/database/schema";

let testDb: BetterSQLite3Database<typeof schema>;
let testSqlite: Database.Database;

vi.mock("@/infrastructure/database/client", () => ({
  get db() {
    return testDb;
  },
}));

import { SQLitePhotoRepository } from "@/infrastructure/database/repositories/SQLitePhotoRepository";
```

In `beforeEach`: call `createTestDb()` and assign to `testDb`/`testSqlite`, create fresh `repo = new SQLitePhotoRepository()`.
In `afterEach`: call `testSqlite.close()`.

**Create a `makePhoto` factory** with auto-incrementing IDs and sensible defaults matching the Photo interface:

- id: `test-photo-${counter}`, title: null, description: null, originalFilename: "test.jpg", blurDataUrl: null, exifData: null, width: null, height: null, status: "ready", createdAt/updatedAt: `new Date("2024-01-01T00:00:00Z")`.

**Also create a `makeAlbum` factory** (needed for junction tests):

- id: `test-album-${counter}`, title: `Test Album ${counter}`, description: null, tags: null, coverPhotoId: null, sortOrder: 0, isPublished: false, createdAt: `new Date("2024-01-01T00:00:00Z")`.
- Save albums using raw Drizzle inserts: `testDb.insert(schema.albums).values(...)`.

**Test cases to write:**

1. **CRUD basics:**
   - `save() + findById()` -- saves a photo and retrieves it with matching fields
   - `findById()` returns null for non-existent ID
   - `findAll()` returns all saved photos
   - `save()` on existing ID performs upsert (update description, verify changed)
   - `delete()` removes photo, `findById()` returns null after

2. **Junction table operations:**
   - `addToAlbum()` + `getAlbumIds()` -- add photo to album, verify albumId returned
   - `addToAlbum()` twice to same album is idempotent (onConflictDoNothing)
   - `removeFromAlbum()` removes the association
   - `findByAlbumId()` returns photos in the album ordered by sortOrder
   - `updatePhotoSortOrders()` reorders photos within an album
   - `findBySlugPrefix()` finds photo by ID prefix

3. **findRandomFromPublishedAlbums:**
   - Returns only photos from published albums with status "ready"
   - Respects the limit parameter

4. **Serialization edge cases (UNIT-02):**
   - ExifData round-trip: save photo with full ExifData object, retrieve, `expect(result.exifData).toEqual(exifData)`
   - Null ExifData: save photo with `exifData: null`, retrieve, `expect(result.exifData).toBeNull()`
   - Corrupt ExifData JSON (via raw SQL): insert row with `'{invalid json}'` in exif_data column, call `findById()`, verify `exifData` is null (safeParseExifJson catches error)
   - Unicode filename: save with `originalFilename: "foto_été_☃.jpg"`, verify round-trip
   - Zero dimensions: save with `width: 0, height: 0`, verify they survive as `0` (not null) because `??` operator preserves 0
   - Timestamp precision: save with known Date, retrieve, compare via `.getTime()`
   - All Photo status values: test with "processing", "ready", "error"

**Timestamp comparison:** Use `.getTime()` for Date comparisons to avoid reference equality issues.
</action>
<verify>
Run `npx vitest run src/infrastructure/database/__tests__/photo-repository.test.ts` -- all tests pass, no failures, no timeouts, no "database is closed" errors.
</verify>
<done>
All SQLitePhotoRepository methods tested: save, findById, findAll, delete, addToAlbum, removeFromAlbum, getAlbumIds, findByAlbumId, updatePhotoSortOrders, findBySlugPrefix, findRandomFromPublishedAlbums. Serialization edge cases for null EXIF, corrupt JSON EXIF, Unicode filenames, zero dimensions, and timestamp precision all pass.
</done>
</task>

<task type="auto">
  <name>Task 2: Write SQLiteAlbumRepository integration tests</name>
  <files>src/infrastructure/database/__tests__/album-repository.test.ts</files>
  <action>
Create `src/infrastructure/database/__tests__/album-repository.test.ts` with the same setup pattern as Task 1 (lazy getter mock, createTestDb in beforeEach, close in afterEach).

Import `SQLiteAlbumRepository` after the mock declaration. Also import the photo repo and schema for junction-related setup.

**Use the same `makeAlbum` factory** as described in Task 1 (or define locally).

**Also create a `makePhoto` factory** for tests that need photo records (deleteWithPhotos, getPhotoCounts, coverPhotoId).

**Test cases to write:**

1. **CRUD basics:**
   - `save() + findById()` -- saves an album and retrieves with matching fields
   - `findById()` returns null for non-existent ID
   - `findAll()` returns all saved albums
   - `save()` on existing ID performs upsert (update title, verify changed)
   - `delete()` removes album, `findById()` returns null after

2. **Query methods:**
   - `findPublished()` returns only albums with `isPublished: true`
   - `getPhotoCounts()` returns correct count per album (insert photos + junction entries via raw Drizzle)
   - `getPhotoCounts()` returns empty Map when no junction entries exist

3. **Sort order operations:**
   - `updateSortOrders()` sets sortOrder based on array index positions

4. **deleteWithPhotos:**
   - `deleteWithPhotos(id, false)` deletes album, junction entries cascade, but returns empty deletedPhotoIds
   - `deleteWithPhotos(id, true)` returns the photo IDs that were in the album (does NOT delete photo records -- caller is responsible)

5. **Serialization edge cases (UNIT-02):**
   - `isPublished` boolean round-trip: save with `true`, retrieve, `expect(typeof result.isPublished).toBe("boolean")` and `expect(result.isPublished).toBe(true)`
   - Null description: save with `description: null`, retrieve, verify null
   - Null tags: save with `tags: null`, retrieve, verify null
   - Null coverPhotoId: save with `coverPhotoId: null`, retrieve, verify null
   - coverPhotoId with valid photo: save photo first, then album with coverPhotoId referencing it, verify round-trip
   - Timestamp precision: compare via `.getTime()`
     </action>
     <verify>
     Run `npx vitest run src/infrastructure/database/__tests__/album-repository.test.ts` -- all tests pass, no failures.
     </verify>
     <done>
     All SQLiteAlbumRepository methods tested: save, findById, findAll, findPublished, delete, getPhotoCounts, updateSortOrders, deleteWithPhotos. Serialization edge cases for isPublished boolean, null fields, coverPhotoId FK, and timestamp precision all pass.
     </done>
     </task>

</tasks>

<verification>
```bash
# Run both repository test files
npx vitest run src/infrastructure/database/__tests__/

# Verify no test failures

npx vitest run src/infrastructure/database/**tests**/ 2>&1 | grep -E "Tests|✓|✗|FAIL"

# Run full test suite to ensure no regressions

npx vitest run

```
</verification>

<success_criteria>
1. All photo repository tests pass (CRUD, junction, serialization edge cases)
2. All album repository tests pass (CRUD, queries, deleteWithPhotos, serialization)
3. Full test suite passes with no regressions (existing 75 smoke tests + new tests)
4. No "database is closed" or stale reference errors (lazy getter pattern works correctly)
</success_criteria>

<output>
After completion, create `.planning/phases/17-unit-and-integration-testing/17-01-SUMMARY.md`
</output>
```
