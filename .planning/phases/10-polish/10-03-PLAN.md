---
phase: 10-polish
plan: 03
type: execute
wave: 3
depends_on: ["10-02"]
files_modified:
  - Dockerfile
  - .dockerignore
  - docker-compose.yml
autonomous: true

must_haves:
  truths:
    - "Dockerfile builds successfully with multi-stage process"
    - "docker-compose.yml defines web, worker, and redis services"
    - ".dockerignore excludes node_modules, .git, storage, data, .next"
    - "Production build works in Docker container (standalone output)"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage production build (deps -> builder -> runner)"
      contains: "FROM node:22-slim"
      min_lines: 30
    - path: ".dockerignore"
      provides: "Excludes unnecessary files from Docker context"
      contains: "node_modules"
    - path: "docker-compose.yml"
      provides: "Complete deployment with web, worker, and redis services"
      contains: "worker"
  key_links:
    - from: "Dockerfile"
      to: "next.config.ts"
      via: "standalone output generates server.js"
      pattern: "server.js"
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "build context"
      pattern: "build: ."
---

<objective>
Create Docker deployment configuration for production use.

Purpose: Enable the self-hosted photography portfolio to run in Docker containers with proper separation of concerns (web server + background worker + Redis). The project uses three native Node.js modules (sharp, bcrypt, better-sqlite3) that require careful handling in Docker builds.

Output: Multi-stage Dockerfile, .dockerignore, and updated docker-compose.yml with web, worker, and redis services.
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-polish/10-02-SUMMARY.md
@next.config.ts
@docker-compose.yml
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dockerfile and .dockerignore</name>
  <files>
    Dockerfile
    .dockerignore
  </files>
  <action>
1. Create `Dockerfile` with three stages:

**Stage 1 - deps**: Install dependencies with native module build tools.

- Base: `node:22-slim`
- Install `python3 make g++` via apt-get (required for sharp, bcrypt, better-sqlite3 native compilation)
- Clean apt cache after install
- Copy package.json and package-lock.json
- Run `npm ci`

**Stage 2 - builder**: Build the Next.js application.

- Base: `node:22-slim`
- Copy node_modules from deps stage
- Copy all source files
- Set `NEXT_TELEMETRY_DISABLED=1`
- Provide dummy env vars for build-time Zod validation (the env.ts file validates at import time):
  - `DATABASE_PATH=/tmp/build.db`
  - `STORAGE_PATH=/tmp/storage`
  - `AUTH_SECRET=build-time-secret-minimum-thirty-two-chars`
  - `ADMIN_PASSWORD_HASH=build-time-hash`
- Run `npm run build`

**Stage 3 - runner**: Production runtime.

- Base: `node:22-slim`
- Set `NODE_ENV=production` and `NEXT_TELEMETRY_DISABLED=1`
- Create non-root user: `addgroup --system --gid 1001 nodejs` and `adduser --system --uid 1001 nextjs`
- Copy from builder: `public/`, `.next/standalone/`, `.next/static/`
- Copy from deps: `node_modules` (needed for worker process running via tsx)
- Copy from builder: `src/`, `tsconfig.json`, `package.json` (needed for worker tsx execution)
- Create mount points: `/app/data` and `/app/storage` with correct ownership for nextjs user
- Set ownership of copied files to nextjs:nodejs
- Switch to `USER nextjs`
- Expose port 3000
- Set `PORT=3000` and `HOSTNAME="0.0.0.0"`
- Default CMD: `["node", "server.js"]`
- Add HEALTHCHECK: `curl -f http://localhost:3000/ || exit 1` (interval 30s, timeout 10s, retries 3, start-period 40s). Note: curl needs to be installed in runner stage via `apt-get install -y curl` before switching to non-root user.

2. Create `.dockerignore`:
   ```
   node_modules
   .next
   .git
   .gitignore
   data
   storage
   .env
   .env.local
   .planning
   *.md
   .vscode
   .idea
   ```
   This keeps the Docker build context small and prevents accidentally baking data/secrets into the image.
   </action>
   <verify>
   Review the Dockerfile for correctness:

- Three stages with proper COPY --from references
- Build tools installed only in deps stage
- Dummy env vars provided during build
- Non-root user for runner
- Volume mount points created with correct ownership
- HEALTHCHECK configured

Note: Docker is NOT installed on the dev machine (per STATE.md). Verify by reading the file and checking syntax. A full `docker build` test cannot be run locally.
</verify>
<done>
Multi-stage Dockerfile handles native module compilation, builds standalone Next.js output, and runs as non-root user. .dockerignore excludes unnecessary files from build context.
</done>
</task>

<task type="auto">
  <name>Task 2: Update docker-compose.yml with web and worker services</name>
  <files>
    docker-compose.yml
  </files>
  <action>
Update the existing `docker-compose.yml` (currently only has redis service) to add web and worker services:

1. Keep the existing redis service as-is (with healthcheck).

2. Add `web` service:
   - `build: .` (uses the Dockerfile)
   - Ports: `"3000:3000"`
   - Environment variables (using env_file or inline):
     - `DATABASE_PATH=/app/data/portfolio.db`
     - `STORAGE_PATH=/app/storage`
     - `REDIS_URL=redis://redis:6379`
     - `AUTH_SECRET=${AUTH_SECRET}` (from host .env)
     - `ADMIN_PASSWORD_HASH=${ADMIN_PASSWORD_HASH}` (from host .env)
   - Volumes:
     - `./data:/app/data` (SQLite database)
     - `./storage:/app/storage` (photo files)
   - depends_on: redis (condition: service_healthy)
   - restart: unless-stopped

3. Add `worker` service:
   - `build: .` (shares same image)
   - command: `npx tsx src/infrastructure/jobs/worker.ts`
   - Same environment variables as web
   - Same volumes as web (needs access to same database and storage)
   - depends_on: redis (condition: service_healthy)
   - restart: unless-stopped
   - No ports exposed (worker doesn't serve HTTP)

4. Keep existing `redis_data` volume.

Note: Do NOT use `version` key in docker-compose.yml -- it's deprecated in modern Docker Compose. Remove the `version: "3.8"` line from the existing file.
</action>
<verify>
Review docker-compose.yml for correctness:

- Three services: redis, web, worker
- Web and worker share same build context
- Worker overrides CMD with tsx command
- Volumes mount data and storage directories
- Environment variables reference host .env via ${} syntax
- Redis healthcheck present
- No deprecated `version` key

Note: Cannot run `docker compose up` locally (Docker not installed per STATE.md).
</verify>
<done>
docker-compose.yml defines complete deployment stack: redis for job queue, web for Next.js server, worker for image processing. Both web and worker share the same Docker image with different commands. Data persists via volume mounts.
</done>
</task>

</tasks>

<verification>
1. Dockerfile has three stages (deps, builder, runner)
2. Dockerfile uses node:22-slim (not Alpine)
3. Dockerfile installs python3, make, g++ for native modules
4. Dockerfile provides dummy env vars during build
5. Dockerfile runs as non-root user
6. Dockerfile has HEALTHCHECK
7. .dockerignore excludes node_modules, .git, data, storage, .env
8. docker-compose.yml has redis, web, and worker services
9. Worker service overrides CMD to run tsx worker
10. Volumes mount data/ and storage/ directories
</verification>

<success_criteria>

- Dockerfile builds a production-ready image with standalone Next.js output
- docker-compose.yml provides complete deployment with web server, background worker, and Redis
- Native modules (sharp, bcrypt, better-sqlite3) compile correctly in deps stage
- Data and storage persist via Docker volumes (not baked into image)
- Non-root user runs the application
  </success_criteria>

<output>
After completion, create `.planning/phases/10-polish/10-03-SUMMARY.md`
</output>
