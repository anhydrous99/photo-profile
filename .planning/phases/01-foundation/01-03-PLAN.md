---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/infrastructure/database/repositories/SQLitePhotoRepository.ts
  - src/infrastructure/database/repositories/SQLiteAlbumRepository.ts
  - src/infrastructure/database/repositories/index.ts
  - storage/originals/.gitkeep
  - storage/processed/.gitkeep
  - docker-compose.yml
  - package.json
  - .husky/pre-commit
autonomous: true

must_haves:
  truths:
    - "SQLitePhotoRepository implements all PhotoRepository interface methods"
    - "SQLiteAlbumRepository implements all AlbumRepository interface methods"
    - "Repository CRUD operations work against real database"
    - "Storage directories exist for originals and processed images"
    - "Docker Compose starts Redis service"
    - "Pre-commit hooks run ESLint and Prettier on staged files"
    - "Development server runs without errors"
  artifacts:
    - path: "src/infrastructure/database/repositories/SQLitePhotoRepository.ts"
      provides: "Photo repository implementation"
      exports: ["SQLitePhotoRepository"]
    - path: "src/infrastructure/database/repositories/SQLiteAlbumRepository.ts"
      provides: "Album repository implementation"
      exports: ["SQLiteAlbumRepository"]
    - path: "storage/originals/.gitkeep"
      provides: "Original images storage directory"
    - path: "storage/processed/.gitkeep"
      provides: "Processed images storage directory"
    - path: "docker-compose.yml"
      provides: "Redis service for job queue"
      contains: "redis"
    - path: ".husky/pre-commit"
      provides: "Pre-commit hook script"
      contains: "lint-staged"
  key_links:
    - from: "src/infrastructure/database/repositories/SQLitePhotoRepository.ts"
      to: "src/domain/repositories/PhotoRepository.ts"
      via: "implements interface"
      pattern: "implements PhotoRepository"
    - from: "src/infrastructure/database/repositories/SQLitePhotoRepository.ts"
      to: "src/infrastructure/database/client.ts"
      via: "database queries"
      pattern: "import.*db.*from"
    - from: "src/infrastructure/database/repositories/SQLiteAlbumRepository.ts"
      to: "src/domain/repositories/AlbumRepository.ts"
      via: "implements interface"
      pattern: "implements AlbumRepository"
---

<objective>
Implement SQLite repositories for Photo and Album entities, set up file storage structure, and configure development environment with Docker Compose and pre-commit hooks.

Purpose: Complete the infrastructure layer with working database operations and establish the development tooling that ensures code quality throughout the project.

Output: Working repository implementations that pass CRUD tests; storage directories; Docker Compose for Redis; Husky pre-commit hooks running lint-staged.
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SQLite Repositories</name>
  <files>
    src/infrastructure/database/repositories/SQLitePhotoRepository.ts
    src/infrastructure/database/repositories/SQLiteAlbumRepository.ts
    src/infrastructure/database/repositories/index.ts
  </files>
  <action>
Create repository implementations that use Drizzle ORM to implement the domain interfaces.

**SQLitePhotoRepository (src/infrastructure/database/repositories/SQLitePhotoRepository.ts):**

```typescript
import { eq } from "drizzle-orm";
import { db } from "../client";
import { photos, photoAlbums } from "../schema";
import type { PhotoRepository } from "@/domain/repositories/PhotoRepository";
import type { Photo } from "@/domain/entities/Photo";

export class SQLitePhotoRepository implements PhotoRepository {
  async findById(id: string): Promise<Photo | null> {
    const result = await db
      .select()
      .from(photos)
      .where(eq(photos.id, id))
      .limit(1);
    return result[0] ? this.toDomain(result[0]) : null;
  }

  async findAll(): Promise<Photo[]> {
    const results = await db.select().from(photos);
    return results.map(this.toDomain);
  }

  async findByAlbumId(albumId: string): Promise<Photo[]> {
    const results = await db
      .select({ photo: photos })
      .from(photos)
      .innerJoin(photoAlbums, eq(photos.id, photoAlbums.photoId))
      .where(eq(photoAlbums.albumId, albumId));
    return results.map((r) => this.toDomain(r.photo));
  }

  async save(photo: Photo): Promise<void> {
    await db
      .insert(photos)
      .values(this.toDatabase(photo))
      .onConflictDoUpdate({
        target: photos.id,
        set: { ...this.toDatabase(photo), updatedAt: Date.now() },
      });
  }

  async delete(id: string): Promise<void> {
    await db.delete(photos).where(eq(photos.id, id));
  }

  private toDomain(row: typeof photos.$inferSelect): Photo {
    return {
      id: row.id,
      title: row.title,
      description: row.description,
      originalFilename: row.originalFilename,
      status: row.status,
      createdAt: new Date(row.createdAt),
      updatedAt: new Date(row.updatedAt),
    };
  }

  private toDatabase(photo: Photo): typeof photos.$inferInsert {
    return {
      id: photo.id,
      title: photo.title,
      description: photo.description,
      originalFilename: photo.originalFilename,
      status: photo.status,
      createdAt: photo.createdAt.getTime(),
      updatedAt: photo.updatedAt.getTime(),
    };
  }
}
```

**SQLiteAlbumRepository (src/infrastructure/database/repositories/SQLiteAlbumRepository.ts):**

Implement similarly with:

- findById, findAll, findPublished (where isPublished = true), save, delete
- toDomain and toDatabase mappers for type conversion
- Uses `albums` table from schema

**Index file (src/infrastructure/database/repositories/index.ts):**
Re-export both repository classes.

Delete .gitkeep from the repositories directory.
</action>
<verify>
Run `npx tsc --noEmit` - No TypeScript errors.
Verify repositories implement all interface methods by checking imports resolve.
</verify>
<done>
SQLitePhotoRepository implements all PhotoRepository interface methods with proper Drizzle queries. SQLiteAlbumRepository implements all AlbumRepository interface methods. Both use type-safe domain/database mappers.
</done>
</task>

<task type="auto">
  <name>Task 2: Set Up Storage, Docker Compose, and Pre-commit Hooks</name>
  <files>
    storage/originals/.gitkeep
    storage/processed/.gitkeep
    data/.gitkeep
    docker-compose.yml
    package.json
    .husky/pre-commit
  </files>
  <action>
**Create storage directories:**
```
storage/
  originals/    # Original uploaded files (gitignored except .gitkeep)
  processed/    # Generated thumbnails/derivatives (gitignored except .gitkeep)
data/
  .gitkeep      # Database files directory (gitignored except .gitkeep)
```

Create .gitkeep file in each directory to ensure they're tracked.

**Create docker-compose.yml:**

```yaml
version: "3.8"

services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  redis_data:
```

**Install and configure Husky + lint-staged:**

```bash
npm install -D husky lint-staged eslint-config-prettier
npx husky init
```

**Update package.json:**
Add to scripts:

```json
{
  "prepare": "husky",
  "lint": "next lint",
  "lint:fix": "next lint --fix",
  "format": "prettier --write .",
  "format:check": "prettier --check .",
  "typecheck": "tsc --noEmit"
}
```

Add lint-staged configuration:

```json
{
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": ["eslint --fix", "prettier --write"],
    "*.{json,md,yml,yaml}": ["prettier --write"]
  }
}
```

**Create .husky/pre-commit:**

```bash
npx lint-staged
```

**Update eslint.config.mjs:**
Extend with prettier config to avoid conflicts (eslint-config-prettier).

**Test the full setup:**

1. Start Redis: `docker compose up -d`
2. Run dev server: `npm run dev`
3. Verify pre-commit hook: Make a small change, stage it, commit - should run lint-staged
   </action>
   <verify>
   Run `docker compose up -d` - Redis starts successfully.
   Run `docker compose ps` - Shows redis service running.
   Run `ls storage/originals storage/processed data` - All directories exist with .gitkeep.
   Run `npm run lint` - ESLint runs without errors.
   Run `npm run typecheck` - TypeScript compiles without errors.
   Stage a file and run `git commit --dry-run` - Pre-commit hook triggers lint-staged.
   </verify>
   <done>
   Storage directories exist for originals and processed images. Docker Compose runs Redis for job queue. Husky pre-commit hooks run lint-staged on staged files. All npm scripts work correctly.
   </done>
   </task>

</tasks>

<verification>
1. `npx tsc --noEmit` - No TypeScript errors
2. `npm run dev` - Development server starts
3. `docker compose up -d && docker compose ps` - Redis service running
4. `ls storage/originals storage/processed data` - All directories exist
5. `npm run lint` - Passes
6. `npm run format:check` - Passes (or format first)
7. Test pre-commit: `echo "test" >> README.md && git add README.md && git commit --dry-run -m "test"` - Shows lint-staged output
</verification>

<success_criteria>

- SQLitePhotoRepository implements PhotoRepository interface with working CRUD operations
- SQLiteAlbumRepository implements AlbumRepository interface with working CRUD operations
- Repositories use proper domain/database type mappers
- storage/originals and storage/processed directories exist with .gitkeep
- data/ directory exists for SQLite database file
- Docker Compose starts Redis service without errors
- Husky pre-commit hooks run lint-staged on staged files
- All npm scripts (lint, format, typecheck) work correctly
- Development server runs without errors
- TypeScript compiles without errors
  </success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
