---
phase: 19-performance-production
plan: 03
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - src/infrastructure/database/client.ts
  - src/app/api/images/[photoId]/[filename]/route.ts
  - .planning/baselines/optimizations.md
autonomous: true

must_haves:
  truths:
    - "SQLite database uses WAL journal mode for improved concurrent read/write performance"
    - "Image serving route returns ETag header and responds with 304 Not Modified for matching If-None-Match requests"
    - "Both optimizations are documented with justification from baseline data"
    - "The impact of optimizations is measurable (WAL mode verified via pragma, ETag via curl)"
  artifacts:
    - path: "src/infrastructure/database/client.ts"
      provides: "WAL mode pragma set on database connection"
      contains: "journal_mode = WAL"
    - path: "src/app/api/images/[photoId]/[filename]/route.ts"
      provides: "ETag generation and 304 conditional response"
      contains: "If-None-Match"
    - path: ".planning/baselines/optimizations.md"
      provides: "Documentation of applied optimizations with justification and impact"
  key_links:
    - from: "src/infrastructure/database/client.ts"
      to: "SQLite database file"
      via: "pragma call after Database() constructor"
      pattern: "pragma.*journal_mode.*WAL"
    - from: "src/app/api/images/[photoId]/[filename]/route.ts"
      to: "HTTP conditional request protocol"
      via: "ETag header and If-None-Match check"
      pattern: "if-none-match.*etag"
---

<objective>
Apply targeted performance optimizations informed by baseline measurement data: SQLite WAL mode and ETag/304 for image serving.

Purpose: PERF-05 requires at least one targeted optimization informed by measurement data, with its impact measured against the baseline. This plan applies two well-justified optimizations: WAL mode for database performance and ETag/304 for image serving bandwidth savings. Both are informed by the codebase state documented in the research (no WAL mode set, no conditional request support despite immutable Cache-Control).

Output: WAL mode enabled on the SQLite connection, ETag/304 support on the image serving route, and a documentation file recording the justification and impact of each optimization.
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-performance-production/19-RESEARCH.md
@.planning/phases/19-performance-production/19-01-SUMMARY.md
@src/infrastructure/database/client.ts
@src/app/api/images/[photoId]/[filename]/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable SQLite WAL mode and add ETag/304 to image serving</name>
  <files>src/infrastructure/database/client.ts, src/app/api/images/[photoId]/[filename]/route.ts</files>
  <action>
1. **Enable WAL mode in `src/infrastructure/database/client.ts`:**

Add the WAL pragma immediately after the Database constructor, BEFORE the drizzle() call. The current code is:

```typescript
const sqlite = new Database(dbPath);
export const db = drizzle({ client: sqlite, schema });
```

Change to:

```typescript
const sqlite = new Database(dbPath);
sqlite.pragma("journal_mode = WAL");
export const db = drizzle({ client: sqlite, schema });
```

This is a one-line addition. WAL mode provides significantly better concurrent read/write performance (readers don't block writers). It persists to the database file once set, but we set it on every connection open for reliability.

Do NOT add `synchronous = normal` pragma -- while safe with WAL, the default `synchronous = full` provides better durability guarantees and the performance difference is negligible for this single-user app.

2. **Add ETag/304 support to `src/app/api/images/[photoId]/[filename]/route.ts`:**

   The `serveImage` function currently reads the file and always returns 200. Add ETag generation and conditional request handling.

   a. Add import at top:

   ```typescript
   import { createHash } from "crypto";
   ```

   b. Add an ETag generation helper:

   ```typescript
   function generateETag(mtimeMs: number, size: number): string {
     const hash = createHash("md5")
       .update(`${mtimeMs}-${size}`)
       .digest("hex")
       .slice(0, 16);
     return `"${hash}"`;
   }
   ```

   c. Modify the `serveImage` function to accept a `request` parameter and handle conditional requests:

   ```typescript
   async function serveImage(
     request: Request,
     filePath: string,
     mimeType: string,
   ): Promise<NextResponse> {
     const fileStat = await stat(filePath);
     const etag = generateETag(fileStat.mtimeMs, fileStat.size);

     // Return 304 if client has current version
     const ifNoneMatch = request.headers.get("if-none-match");
     if (ifNoneMatch === etag) {
       return new NextResponse(null, {
         status: 304,
         headers: { ETag: etag },
       });
     }

     const fileBuffer = await readFile(filePath);

     return new NextResponse(fileBuffer, {
       status: 200,
       headers: {
         "Content-Type": mimeType,
         "Content-Length": fileStat.size.toString(),
         "Cache-Control": "public, max-age=31536000, immutable",
         ETag: etag,
       },
     });
   }
   ```

   d. Update the `GET` function to change `_request` to `request` (remove the underscore prefix) and pass `request` to `serveImage` calls. There are two calls to `serveImage` in the function:
   - Line ~100: `return await serveImage(filePath, mimeType);` -> `return await serveImage(request, filePath, mimeType);`
   - Line ~111: `return await serveImage(join(photoDir, fallback), mimeType);` -> `return await serveImage(request, join(photoDir, fallback), mimeType);`

   Also update the destructured params: change `_request: Request` to `request: Request`.

   **Key optimization benefit:** With immutable Cache-Control, browsers won't re-request images during their cache lifetime. But if the cache is cleared or expired, the ETag enables a lightweight 304 response instead of re-sending the full image file. This saves significant bandwidth for large image derivatives.
   </action>
   <verify>

- `npm run typecheck` passes
- `npm run lint` passes
- `npm run build` succeeds
- Verify WAL mode: Add a temporary test or use the existing test infrastructure. The WAL mode can be verified by checking the database client sets the pragma. A simple check: `node -e "const Database = require('better-sqlite3'); const db = new Database('./data/portfolio.db'); console.log(db.pragma('journal_mode'))"` should show `[{ journal_mode: 'wal' }]` after the app has been started once.
- Verify ETag: The route should include ETag in response headers. Check with: inspect the code to confirm `ETag` is in the response headers object and `if-none-match` is checked.
  </verify>
  <done>SQLite WAL mode is enabled on database connection. Image serving route generates ETag headers and returns 304 for conditional requests with matching If-None-Match.</done>
  </task>

<task type="auto">
  <name>Task 2: Document optimizations with justification and impact</name>
  <files>.planning/baselines/optimizations.md</files>
  <action>
Create `.planning/baselines/optimizations.md` documenting the optimizations applied, their justification from research/baseline data, and how to verify their impact.

````markdown
# Targeted Optimizations

**Date:** [today's date]
**Phase:** 19-03 (Performance & Production)
**Requirement:** PERF-05

## Optimization 1: SQLite WAL Mode

**What:** Enabled Write-Ahead Logging (WAL) journal mode on the SQLite database connection.

**File:** `src/infrastructure/database/client.ts`

**Justification:**

- Research finding: Database client had no journal_mode pragma set (defaulting to "delete" rollback journal)
- WAL mode provides significantly better concurrent read/write performance -- readers never block writers
- Industry consensus since 2020 recommends WAL as the default for production SQLite
- Source: SQLite WAL documentation (https://sqlite.org/wal.html), better-sqlite3 performance docs

**Impact:**

- Concurrent reads during writes are no longer blocked (critical when the image processing worker updates photo status while the public gallery serves read queries)
- Verify: `PRAGMA journal_mode` returns `wal` instead of `delete`
- Command: `node -e "const Database = require('better-sqlite3'); const db = new Database('./data/portfolio.db'); console.log(db.pragma('journal_mode'))"`

## Optimization 2: ETag/304 for Image Serving

**What:** Added ETag header generation (based on file mtime + size) and conditional request handling (If-None-Match -> 304 Not Modified) to the image serving API route.

**File:** `src/app/api/images/[photoId]/[filename]/route.ts`

**Justification:**

- Research finding: Image route had `Cache-Control: immutable` but no ETag/304 support
- While `immutable` prevents re-validation during cache lifetime, cache clears (browser update, user action, cache eviction) cause full re-download
- Image derivatives range from ~20KB (300w thumbnails) to ~500KB (2400w full-size), making conditional responses a significant bandwidth saving
- ETag based on mtime+size is lightweight (no file content hashing needed) and correct for static derivatives that never change in-place

**Impact:**

- Cache-cleared or expired requests return 304 (empty body) instead of re-sending the full image
- Typical bandwidth saving: 20KB-500KB per conditional request
- Verify with curl:

  ```bash
  # First request -- gets full image + ETag
  curl -I http://localhost:3000/api/images/{photoId}/300w.webp
  # Note the ETag header value

  # Second request with If-None-Match -- should get 304
  curl -I -H 'If-None-Match: "{etag-value}"' http://localhost:3000/api/images/{photoId}/300w.webp
  ```
````

```
  </action>
  <verify>
- `.planning/baselines/optimizations.md` exists with both optimizations documented
- Document includes justification, file paths, and verification commands
  </verify>
  <done>Both optimizations are documented with research-backed justification, affected file paths, and commands to verify their impact.</done>
</task>

</tasks>

<verification>
- `npm run typecheck` passes
- `npm run lint` passes
- `npm run build` succeeds
- WAL mode is set in database client initialization
- Image route includes ETag in response headers
- Image route checks If-None-Match and returns 304 when matched
- Optimizations document exists with justification and verification instructions
</verification>

<success_criteria>
1. `sqlite.pragma("journal_mode = WAL")` is called in client.ts before any database operations
2. Image serving route generates ETag from file mtime+size and includes it in response headers
3. Image serving route returns 304 Not Modified when client sends matching If-None-Match
4. Both optimizations are documented with justification from research data
5. All existing tests and type checks continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/19-performance-production/19-03-SUMMARY.md`
</output>
```
