---
phase: 19-performance-production
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/infrastructure/logging/logger.ts
  - src/infrastructure/config/env.ts
  - src/app/api/health/route.ts
  - src/infrastructure/database/client.ts
  - src/infrastructure/jobs/worker.ts
  - src/infrastructure/jobs/workers/imageProcessor.ts
  - src/infrastructure/jobs/load-env.ts
  - src/infrastructure/auth/rateLimiter.ts
  - src/infrastructure/database/repositories/SQLitePhotoRepository.ts
  - src/app/api/admin/upload/route.ts
  - src/app/api/admin/albums/route.ts
  - src/app/api/admin/albums/reorder/route.ts
  - src/app/api/admin/albums/[id]/route.ts
  - src/app/api/admin/albums/[id]/photos/reorder/route.ts
  - src/app/api/admin/photos/[id]/route.ts
  - src/app/api/admin/photos/[id]/albums/route.ts
  - src/app/api/admin/photos/[id]/reprocess/route.ts
  - src/app/api/images/[photoId]/[filename]/route.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/health returns 200 with { status: 'healthy' } when database and storage are accessible"
    - "GET /api/health returns 503 with { status: 'unhealthy' } when database or storage is unavailable"
    - "A structured logger utility exists with debug/info/warn/error levels"
    - "Logger outputs JSON in production and human-readable prefixed text in development"
    - "LOG_LEVEL env var controls minimum log level with sensible defaults"
    - "All server-side console.log/warn/error calls are replaced with the structured logger (except client-side error boundaries and test fixtures)"
  artifacts:
    - path: "src/infrastructure/logging/logger.ts"
      provides: "Structured logging utility"
      exports: ["logger"]
    - path: "src/app/api/health/route.ts"
      provides: "Health check endpoint"
      exports: ["GET"]
    - path: "src/infrastructure/config/env.ts"
      provides: "LOG_LEVEL optional env var"
      contains: "LOG_LEVEL"
  key_links:
    - from: "src/app/api/health/route.ts"
      to: "src/infrastructure/database/client.ts"
      via: "import db, run SELECT 1"
      pattern: "db\\.run.*SELECT 1"
    - from: "src/app/api/health/route.ts"
      to: "src/infrastructure/config/env.ts"
      via: "import env for STORAGE_PATH"
      pattern: "env\\.STORAGE_PATH"
    - from: "src/infrastructure/logging/logger.ts"
      to: "all server-side files"
      via: "import { logger } replacing console.*"
      pattern: "import.*logger.*from.*logging/logger"
---

<objective>
Create a health check endpoint and structured logging utility, then replace all server-side console.* calls with the logger.

Purpose: PERF-03 requires a health check endpoint that verifies database and storage accessibility. PERF-04 requires structured logging with log levels and JSON output. This plan builds both utilities and migrates all server-side console usage.

Output: Health check API route, structured logger module, LOG_LEVEL env var, and all server-side console calls replaced with logger calls.
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-performance-production/19-RESEARCH.md
@src/infrastructure/config/env.ts
@src/infrastructure/database/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create structured logger and health check endpoint</name>
  <files>src/infrastructure/logging/logger.ts, src/infrastructure/config/env.ts, src/app/api/health/route.ts</files>
  <action>
1. **Add LOG_LEVEL to env schema** in `src/infrastructure/config/env.ts`:
   - Add an optional `LOG_LEVEL` field to the Zod schema with values: "debug", "info", "warn", "error"
   - Default: `"info"` in production, `"debug"` in development
   - Use `.optional()` with a `.default()` that checks NODE_ENV:
   ```typescript
   LOG_LEVEL: z.enum(["debug", "info", "warn", "error"]).optional(),
   ```
   Do NOT use `.default()` on the schema -- handle the default inside the logger itself based on NODE_ENV to avoid circular dependency issues. Just make it optional.

2. **Create `src/infrastructure/logging/logger.ts`** (~50 lines, lightweight custom logger):

   ```typescript
   type LogLevel = "debug" | "info" | "warn" | "error";

   const LOG_LEVELS: Record<LogLevel, number> = {
     debug: 0,
     info: 1,
     warn: 2,
     error: 3,
   };

   function getCurrentLevel(): LogLevel {
     const envLevel = process.env.LOG_LEVEL as LogLevel | undefined;
     if (envLevel && envLevel in LOG_LEVELS) return envLevel;
     return process.env.NODE_ENV === "production" ? "info" : "debug";
   }

   interface LogEntry {
     level: LogLevel;
     msg: string;
     timestamp: string;
     [key: string]: unknown;
   }

   function log(level: LogLevel, msg: string, data?: Record<string, unknown>) {
     if (LOG_LEVELS[level] < LOG_LEVELS[getCurrentLevel()]) return;

     const entry: LogEntry = {
       level,
       msg,
       timestamp: new Date().toISOString(),
       ...data,
     };

     // Handle Error objects in data -- Error.stack is not enumerable
     if (data) {
       for (const [key, value] of Object.entries(data)) {
         if (value instanceof Error) {
           entry[key] = { message: value.message, stack: value.stack };
         }
       }
     }

     const method =
       level === "error"
         ? console.error
         : level === "warn"
           ? console.warn
           : console.log;

     if (process.env.NODE_ENV === "production") {
       method(JSON.stringify(entry));
     } else {
       const prefix = `[${level.toUpperCase()}]`;
       method(prefix, msg, data ? data : "");
     }
   }

   export const logger = {
     debug: (msg: string, data?: Record<string, unknown>) =>
       log("debug", msg, data),
     info: (msg: string, data?: Record<string, unknown>) =>
       log("info", msg, data),
     warn: (msg: string, data?: Record<string, unknown>) =>
       log("warn", msg, data),
     error: (msg: string, data?: Record<string, unknown>) =>
       log("error", msg, data),
   };
   ```

   **IMPORTANT:** The logger reads `process.env.LOG_LEVEL` directly (NOT via the `env` import from config/env.ts) to avoid circular dependency issues. The config/env.ts module loads early and some files that import the logger are loaded before or during env initialization.

3. **Create `src/app/api/health/route.ts`**:

   ```typescript
   import { NextResponse } from "next/server";
   import { db } from "@/infrastructure/database/client";
   import { sql } from "drizzle-orm";
   import { access, constants } from "fs/promises";
   import { env } from "@/infrastructure/config/env";

   export async function GET() {
     const checks: Record<string, { status: string; error?: string }> = {
       database: { status: "ok" },
       storage: { status: "ok" },
     };

     // DB check: simple query
     try {
       db.run(sql`SELECT 1`);
     } catch (e) {
       checks.database = {
         status: "error",
         error: e instanceof Error ? e.message : "Unknown database error",
       };
     }

     // Storage check: verify directory is readable and writable
     try {
       await access(env.STORAGE_PATH, constants.R_OK | constants.W_OK);
     } catch (e) {
       checks.storage = {
         status: "error",
         error: e instanceof Error ? e.message : "Unknown storage error",
       };
     }

     const allOk = Object.values(checks).every((c) => c.status === "ok");

     return NextResponse.json(
       { status: allOk ? "healthy" : "unhealthy", checks },
       { status: allOk ? 200 : 503 },
     );
   }
   ```

   The health endpoint must NOT be behind auth -- it is a public operational endpoint.
   </action>
   <verify>

- `npm run typecheck` passes
- `npm run lint` passes
- `src/infrastructure/logging/logger.ts` exports `logger` with debug/info/warn/error methods
- `src/app/api/health/route.ts` exports a GET handler
- `src/infrastructure/config/env.ts` has LOG_LEVEL as optional field
  </verify>
  <done>Health check endpoint returns 200/healthy or 503/unhealthy based on DB and storage status. Structured logger exists with level-based filtering and JSON output in production.</done>
  </task>

<task type="auto">
  <name>Task 2: Replace all server-side console.* calls with structured logger</name>
  <files>
    src/infrastructure/database/client.ts,
    src/infrastructure/jobs/worker.ts,
    src/infrastructure/jobs/workers/imageProcessor.ts,
    src/infrastructure/jobs/load-env.ts,
    src/infrastructure/auth/rateLimiter.ts,
    src/infrastructure/database/repositories/SQLitePhotoRepository.ts,
    src/infrastructure/config/env.ts,
    src/app/api/admin/upload/route.ts,
    src/app/api/admin/albums/route.ts,
    src/app/api/admin/albums/reorder/route.ts,
    src/app/api/admin/albums/[id]/route.ts,
    src/app/api/admin/albums/[id]/photos/reorder/route.ts,
    src/app/api/admin/photos/[id]/route.ts,
    src/app/api/admin/photos/[id]/albums/route.ts,
    src/app/api/admin/photos/[id]/reprocess/route.ts,
    src/app/api/images/[photoId]/[filename]/route.ts
  </files>
  <action>
Replace all server-side `console.log/warn/error` calls with structured logger equivalents. Add `import { logger } from "@/infrastructure/logging/logger"` to each modified file.

**DO NOT replace:**

- Client-side error boundaries (4 .tsx files: `src/app/admin/(protected)/error.tsx`, `src/app/albums/[id]/error.tsx`, `src/app/global-error.tsx`, `src/app/error.tsx`) -- these run in the browser where the server-side logger is not available
- Test fixtures (`src/__tests__/fixtures/generate-fixtures.ts`) -- test scripts should use plain console
- Test files (`src/infrastructure/database/__tests__/photo-repository.test.ts`) -- test comments, not actual console calls

**Replacement rules:**

- `console.log("[Worker] Starting...")` -> `logger.info("Worker starting")`
- `console.log("[DB] Added exif_data...")` -> `logger.info("Added exif_data column to photos table", { component: "db" })`
- `console.error("[API] GET /api/...", error)` -> `logger.error("GET /api/... failed", { error: error instanceof Error ? { message: error.message, stack: error.stack } : error })`
- `console.warn("[Rate Limiter] ...")` -> `logger.warn("Rate limiter: ...", { component: "rate-limiter" })`
- `console.error("Failed to initialize database schema:", error)` -> `logger.error("Failed to initialize database schema", { error: error instanceof Error ? { message: error.message, stack: error.stack } : error })`

**Pattern for each file:**

1. Add `import { logger } from "@/infrastructure/logging/logger";` at the top
2. Replace each `console.log(...)` with `logger.info(...)` or `logger.debug(...)` (use debug for verbose output like env loading details)
3. Replace each `console.error(...)` with `logger.error(...)`, extracting Error objects properly
4. Replace each `console.warn(...)` with `logger.warn(...)`
5. Preserve the semantic meaning of each log -- keep the context (route path, component name, job ID) as structured data fields

**Special cases:**

- `src/infrastructure/config/env.ts` (line 19): The `console.error` for invalid env vars should use `logger.error`. BUT be careful -- the logger reads `process.env.LOG_LEVEL` directly, NOT from the env config, so there is no circular dependency. Import the logger and replace.
- `src/infrastructure/jobs/load-env.ts`: This file runs before the app loads (it's a standalone env loader for the worker process). Replace with logger but note the logger will use process.env directly which is fine.
- `src/infrastructure/jobs/worker.ts`: Worker lifecycle messages (starting, shutdown, errors). Replace with logger.info for lifecycle and logger.error for errors.
- `src/infrastructure/jobs/workers/imageProcessor.ts`: Job processing messages. Use logger.info for progress, logger.error for failures. Include jobId and photoId as structured data.

**File count:** 16 server-side files need modification. Verify with `grep -r "console\." src/ --include="*.ts" -l` after changes -- should only show test files.
</action>
<verify>

- `npm run typecheck` passes
- `npm run lint` passes
- `grep -r "console\." src/ --include="*.ts" -l` returns ONLY: `src/__tests__/fixtures/generate-fixtures.ts` and `src/infrastructure/database/__tests__/photo-repository.test.ts`
- `grep -r "console\." src/ --include="*.tsx" -l` returns ONLY error boundary files (4 files)
- Every modified file imports `logger` from `@/infrastructure/logging/logger`
  </verify>
  <done>All server-side console.log/warn/error calls (across 16 files) are replaced with structured logger calls. Client-side error boundaries and test fixtures are unchanged. Zero raw console calls remain in server-side code.</done>
  </task>

</tasks>

<verification>
- `npm run typecheck` passes
- `npm run lint` passes
- `npm run build` succeeds (ensures health route and logger work at build time)
- Health check endpoint logic is correct (200/healthy when ok, 503/unhealthy when not)
- No server-side files use raw `console.*` (only client error boundaries and test fixtures)
- Logger outputs JSON in production mode and prefixed text in development
</verification>

<success_criteria>

1. GET /api/health returns 200 with `{ status: "healthy", checks: { database: { status: "ok" }, storage: { status: "ok" } } }`
2. Structured logger exists at `src/infrastructure/logging/logger.ts` with debug/info/warn/error
3. LOG_LEVEL env var is optional in the schema
4. All 16 server-side files use logger instead of console
5. Logger handles Error objects without losing stack traces
   </success_criteria>

<output>
After completion, create `.planning/phases/19-performance-production/19-02-SUMMARY.md`
</output>
