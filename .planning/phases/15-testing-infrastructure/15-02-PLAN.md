---
phase: 15-testing-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - vitest.config.ts
  - src/__tests__/fixtures/generate-fixtures.ts
  - src/__tests__/fixtures/tiny-landscape.jpg
  - src/__tests__/fixtures/tiny-portrait.jpg
  - src/__tests__/fixtures/tiny-no-exif.png
  - src/infrastructure/__tests__/mocks.smoke.test.ts
  - src/infrastructure/__tests__/test-db.smoke.test.ts
  - src/infrastructure/__tests__/fixtures.smoke.test.ts
autonomous: true

must_haves:
  truths:
    - "Fixture images exist and are loadable by Sharp for EXIF and dimension assertions"
    - "Running npx vitest run --coverage produces a V8 coverage report for src/infrastructure/"
    - "At least one smoke test per category (Next.js mocks, Redis mock, database helper, fixtures) passes"
  artifacts:
    - path: "src/__tests__/fixtures/tiny-landscape.jpg"
      provides: "8x6 JPEG with EXIF data (Make, Model) for testing"
    - path: "src/__tests__/fixtures/tiny-portrait.jpg"
      provides: "6x8 JPEG with EXIF data for portrait orientation testing"
    - path: "src/__tests__/fixtures/tiny-no-exif.png"
      provides: "8x8 PNG without EXIF for no-metadata edge case testing"
    - path: "src/__tests__/fixtures/generate-fixtures.ts"
      provides: "Script to regenerate fixture images if needed"
    - path: "src/infrastructure/__tests__/mocks.smoke.test.ts"
      provides: "Smoke tests proving Next.js and Redis mocks work"
      min_lines: 20
    - path: "src/infrastructure/__tests__/test-db.smoke.test.ts"
      provides: "Smoke tests proving in-memory DB has correct schema and supports Drizzle queries"
      min_lines: 30
    - path: "src/infrastructure/__tests__/fixtures.smoke.test.ts"
      provides: "Smoke tests proving fixture images are readable by Sharp with expected properties"
      min_lines: 15
  key_links:
    - from: "src/infrastructure/__tests__/test-db.smoke.test.ts"
      to: "src/__tests__/helpers/test-db.ts"
      via: "import createTestDb"
      pattern: "import.*createTestDb.*test-db"
    - from: "src/infrastructure/__tests__/fixtures.smoke.test.ts"
      to: "src/__tests__/fixtures/tiny-landscape.jpg"
      via: "sharp(fixturePath) to read and validate"
      pattern: "sharp.*tiny-landscape"
    - from: "vitest.config.ts"
      to: "coverage"
      via: "coverage.provider and coverage.include config"
      pattern: "provider.*v8"
---

<objective>
Install the coverage provider, generate test fixture images, configure coverage reporting, and write smoke tests that prove the entire test infrastructure works end-to-end.

Purpose: This plan validates everything Plan 01 set up. The smoke tests serve as both validation AND as examples for future test authors (Phase 17). The coverage config enables tracking test coverage across the infrastructure layer.

Output: Fixture images committed to repo, coverage config in vitest.config.ts, and passing smoke tests for all mock categories.
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-testing-infrastructure/15-RESEARCH.md
@.planning/phases/15-testing-infrastructure/15-01-SUMMARY.md
@vitest.config.ts
@src/__tests__/setup.ts
@src/__tests__/helpers/test-db.ts
@src/infrastructure/database/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install coverage provider, generate fixtures, and add coverage config</name>
  <files>vitest.config.ts, src/__tests__/fixtures/generate-fixtures.ts, src/__tests__/fixtures/tiny-landscape.jpg, src/__tests__/fixtures/tiny-portrait.jpg, src/__tests__/fixtures/tiny-no-exif.png</files>
  <action>
**Step 1: Install @vitest/coverage-v8**

Run: `npm install -D @vitest/coverage-v8@4.0.18`

The version MUST match vitest@4.0.18 exactly. Mismatched versions cause runtime errors.

**Step 2: Create `src/__tests__/fixtures/generate-fixtures.ts`**

A script that generates 3 tiny test images using Sharp:

1. `tiny-landscape.jpg` — 8x6 pixel JPEG with EXIF data:
   - `sharp({ create: { width: 8, height: 6, channels: 3, background: { r: 100, g: 150, b: 200 } } })`
   - `.jpeg({ quality: 90 })`
   - `.withExif({ IFD0: { Make: "TestCamera", Model: "TestModel X100", ImageDescription: "Test landscape image" } })`
   - Save to `path.join(__dirname, "tiny-landscape.jpg")`

2. `tiny-portrait.jpg` — 6x8 pixel JPEG with EXIF data:
   - `sharp({ create: { width: 6, height: 8, channels: 3, background: { r: 200, g: 100, b: 100 } } })`
   - `.jpeg({ quality: 90 })`
   - `.withExif({ IFD0: { Make: "AnotherBrand", Model: "Pro 50" } })`
   - Save to `path.join(__dirname, "tiny-portrait.jpg")`

3. `tiny-no-exif.png` — 8x8 pixel PNG without EXIF:
   - `sharp({ create: { width: 8, height: 8, channels: 4, background: { r: 0, g: 0, b: 0, alpha: 0.5 } } })`
   - `.png()`
   - Save to `path.join(__dirname, "tiny-no-exif.png")`

Use `import { fileURLToPath } from "url"` and `import { dirname } from "path"` to compute `__dirname` in ESM context, OR use `import.meta.url`. Check whether the project uses CommonJS or ESM modules for scripts — the project uses TypeScript with vitest so `__dirname` should work via tsx. Use `path.resolve(__dirname)` or `path.join(process.cwd(), "src/__tests__/fixtures/")` for safety.

**Step 3: Run the fixture generator**

Execute: `npx tsx src/__tests__/fixtures/generate-fixtures.ts`

Verify the 3 fixture files were created.

**Step 4: Update vitest.config.ts to add coverage configuration**

Add the `coverage` section to the existing `test` config:

```typescript
coverage: {
  provider: "v8",
  include: ["src/infrastructure/**/*.ts"],
  exclude: [
    "src/infrastructure/jobs/worker.ts",
    "src/infrastructure/jobs/load-env.ts",
  ],
  reporter: ["text", "html", "json"],
  reportsDirectory: "./coverage",
},
```

Important: Do NOT use `coverage.all` (removed in Vitest 4.x). Use `coverage.include` patterns instead.

Exclude `worker.ts` (standalone process) and `load-env.ts` (dotenv loader for worker) from coverage since they are entry points not importable in tests.
</action>
<verify>

1. `ls src/__tests__/fixtures/` shows tiny-landscape.jpg, tiny-portrait.jpg, tiny-no-exif.png, generate-fixtures.ts
2. `npx vitest run --coverage --passWithNoTests 2>&1 | head -20` produces coverage output without errors
3. File sizes: fixtures should be 1-3KB each (not megabytes)
   </verify>
   <done>@vitest/coverage-v8 installed, 3 fixture images generated and committed, coverage config added to vitest.config.ts targeting src/infrastructure/</done>
   </task>

<task type="auto">
  <name>Task 2: Write smoke tests for all mock categories</name>
  <files>src/infrastructure/__tests__/mocks.smoke.test.ts, src/infrastructure/__tests__/test-db.smoke.test.ts, src/infrastructure/__tests__/fixtures.smoke.test.ts</files>
  <action>
Create 3 smoke test files that prove the test infrastructure works. These tests validate Plan 01's setup AND serve as usage examples for Phase 17.

**File 1: `src/infrastructure/__tests__/mocks.smoke.test.ts`** — Next.js and Redis mock smoke tests.

Tests to write:

- `"can import server-only without crashing"` — `await import("server-only")` should resolve without throwing
- `"can import next/headers and call cookies()"` — Import `cookies` from `next/headers`, call it, verify `.get` is defined
- `"can import next/cache and call revalidatePath()"` — Import `revalidatePath` from `next/cache`, call it with a path string, no crash
- `"can import auth session module"` — `await import("@/infrastructure/auth/session")` should resolve, verify `encrypt` and `decrypt` are defined
- `"can import auth dal module"` — `await import("@/infrastructure/auth/dal")` should resolve, verify `verifySession` is defined
- `"can import ioredis without hanging"` — Import `default` from `ioredis`, call `new IORedis()`, verify the instance is defined (should NOT hang)
- `"can import queues module without hanging"` — `await import("@/infrastructure/jobs/queues")` should resolve, verify `imageQueue` is defined

Use `describe("Mock smoke tests", () => { ... })` grouping.

**File 2: `src/infrastructure/__tests__/test-db.smoke.test.ts`** — In-memory database smoke tests.

Tests to write:

- `"creates in-memory database with correct photos schema"` — Call `createTestDb()`, run `PRAGMA table_info(photos)`, verify columns include: id, title, description, original_filename, blur_data_url, status, created_at, updated_at, exif_data, width, height (11 columns total)
- `"creates in-memory database with correct albums schema including tags"` — Call `createTestDb()`, run `PRAGMA table_info(albums)`, verify columns include: id, title, description, tags, cover_photo_id, sort_order, is_published, created_at
- `"albums cover_photo_id FK has ON DELETE SET NULL"` — Call `createTestDb()`, run `PRAGMA foreign_key_list(albums)`, find the FK on cover_photo_id, verify `on_delete` is `"SET NULL"`
- `"can insert and query photos via Drizzle ORM"` — Insert a photo with `db.insert(photos).values(...)`, query with `db.select().from(photos).all()`, verify length 1 and id matches
- `"can insert album and link to photo via junction table"` — Insert photo, insert album, insert photo_album, query all three and verify relationships
- `"cascade deletes work on photo_albums"` — Insert photo + album + junction row, delete the photo, verify junction row is gone

Import `createTestDb` from `@/__tests__/helpers/test-db`. Import `photos`, `albums`, `photoAlbums` from `@/infrastructure/database/schema`. Import `eq` from `drizzle-orm` for WHERE clauses.

Each test should call `createTestDb()` at the start and `sqlite.close()` at the end (use `afterEach` or inline cleanup).

**File 3: `src/infrastructure/__tests__/fixtures.smoke.test.ts`** — Fixture image smoke tests.

Tests to write:

- `"tiny-landscape.jpg is a valid JPEG loadable by Sharp"` — Read with `sharp(fixturePath)`, call `.metadata()`, verify `format` is `"jpeg"`, `width` is 8, `height` is 6
- `"tiny-landscape.jpg has EXIF data"` — Read with `sharp(fixturePath)`, call `.metadata()`, verify `exif` is a Buffer (truthy). Optionally parse with `exif-reader` and check `Make` or `Model`.
- `"tiny-portrait.jpg has portrait dimensions"` — Verify `width` is 6, `height` is 8
- `"tiny-no-exif.png is a valid PNG without EXIF"` — Verify `format` is `"png"`, `width` is 8, `height` is 8, and `exif` is undefined/falsy

Use `path.resolve(__dirname, "../../__tests__/fixtures/tiny-landscape.jpg")` or `path.join(process.cwd(), "src/__tests__/fixtures/tiny-landscape.jpg")` for fixture paths. Prefer `process.cwd()` based paths for reliability.

Import `sharp` from `sharp` (real Sharp, NOT mocked — Sharp works in tests).
</action>
<verify>
Run `npx vitest run` — all smoke tests pass. Expected output should show 3 test files with all tests passing:

- mocks.smoke.test.ts: 7 tests
- test-db.smoke.test.ts: 6 tests
- fixtures.smoke.test.ts: 4 tests

Then run `npx vitest run --coverage` to verify coverage report generates for src/infrastructure/.
</verify>
<done>All smoke tests pass: Next.js mocks prevent crashes, Redis mock prevents hangs, test DB has correct schema with all migrations, fixture images are valid and loadable by Sharp. Coverage report generates successfully.</done>
</task>

</tasks>

<verification>
1. `npx vitest run` passes all smoke tests (17+ test assertions across 3 files) plus the existing theme-tokens test
2. `npx vitest run --coverage` produces coverage output in ./coverage/ directory
3. Coverage report includes src/infrastructure/ files
4. Fixture images are tiny (< 5KB each)
5. No test hangs — entire suite completes within seconds
</verification>

<success_criteria>

- @vitest/coverage-v8@4.0.18 installed as devDependency
- 3 fixture images generated and committed (tiny-landscape.jpg, tiny-portrait.jpg, tiny-no-exif.png)
- vitest.config.ts has coverage config targeting src/infrastructure/\*_/_.ts
- mocks.smoke.test.ts: 7 passing tests proving Next.js/Redis/BullMQ mocks work
- test-db.smoke.test.ts: 6 passing tests proving in-memory DB matches production schema
- fixtures.smoke.test.ts: 4 passing tests proving fixture images are valid for Sharp
- `npx vitest run --coverage` exits 0 and produces report
  </success_criteria>

<output>
After completion, create `.planning/phases/15-testing-infrastructure/15-02-SUMMARY.md`
</output>
