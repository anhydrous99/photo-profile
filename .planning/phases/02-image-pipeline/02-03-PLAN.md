---
phase: 02-image-pipeline
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - src/infrastructure/jobs/workers/imageProcessor.ts
  - src/infrastructure/jobs/worker.ts
  - src/infrastructure/jobs/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Worker processes jobs from image-processing queue"
    - "Worker updates job progress during processing"
    - "Worker handles errors gracefully with logging"
    - "Worker shuts down cleanly on SIGTERM/SIGINT"
    - "Worker can be started via npm script"
  artifacts:
    - path: "src/infrastructure/jobs/workers/imageProcessor.ts"
      provides: "BullMQ worker for image processing jobs"
      exports: ["imageWorker"]
    - path: "src/infrastructure/jobs/worker.ts"
      provides: "Worker entry point with graceful shutdown"
      min_lines: 30
  key_links:
    - from: "src/infrastructure/jobs/workers/imageProcessor.ts"
      to: "src/infrastructure/services/imageService.ts"
      via: "generateDerivatives import"
      pattern: "generateDerivatives"
    - from: "src/infrastructure/jobs/workers/imageProcessor.ts"
      to: "src/infrastructure/jobs/queues.ts"
      via: "queue connection"
      pattern: "image-processing"
---

<objective>
Create the BullMQ worker that processes image jobs, generates derivatives using the image service, and handles graceful shutdown.

Purpose: Complete the async processing pipeline - worker picks up jobs, generates thumbnails, reports progress/completion.
Output: Worker that can be run via `npm run worker` and processes images from the queue.
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-image-pipeline/02-RESEARCH.md
@.planning/phases/02-image-pipeline/02-01-SUMMARY.md
@.planning/phases/02-image-pipeline/02-02-SUMMARY.md

# Prior implementations

@src/infrastructure/jobs/queues.ts
@src/infrastructure/services/imageService.ts
@src/infrastructure/config/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create image processor worker</name>
  <files>
src/infrastructure/jobs/workers/imageProcessor.ts
src/infrastructure/jobs/index.ts
  </files>
  <action>
Create `src/infrastructure/jobs/workers/imageProcessor.ts`:

1. Import Worker and Job from bullmq
2. Import IORedis from ioredis
3. Import path from path
4. Import sharp from sharp
5. Import { env } from @/infrastructure/config/env
6. Import { generateDerivatives } from @/infrastructure/services/imageService
7. Import { ImageJobData, ImageJobResult } from ../queues

8. Create Redis connection (same pattern as queues.ts):
   - `new IORedis(env.REDIS_URL, { maxRetriesPerRequest: null })`

9. Disable Sharp cache for long-running worker:
   - `sharp.cache(false)` - prevents memory buildup

10. Create and export `imageWorker`:

    ```typescript
    export const imageWorker = new Worker<ImageJobData, ImageJobResult>(
      "image-processing",
      async (job: Job<ImageJobData>) => {
        const { photoId, originalPath } = job.data;
        const outputDir = path.join(env.STORAGE_PATH, "processed", photoId);

        console.log(
          `[ImageWorker] Processing job ${job.id} for photo ${photoId}`,
        );

        // Update progress
        await job.updateProgress(10);

        // Generate all derivatives
        const derivatives = await generateDerivatives(originalPath, outputDir);

        await job.updateProgress(100);

        console.log(
          `[ImageWorker] Generated ${derivatives.length} files for photo ${photoId}`,
        );

        return { photoId, derivatives };
      },
      {
        connection,
        concurrency: 2, // Limit concurrent jobs (50MP images use ~144MB each)
      },
    );
    ```

11. Attach error handlers (CRITICAL - worker fails silently without these):

    ```typescript
    imageWorker.on("error", (err) => {
      console.error("[ImageWorker] Error:", err);
    });

    imageWorker.on("failed", (job, err) => {
      console.error(`[ImageWorker] Job ${job?.id} failed:`, err.message);
      // TODO: Update photo status to 'error' in database (Phase 4)
    });

    imageWorker.on("completed", (job, result) => {
      console.log(
        `[ImageWorker] Job ${job.id} completed: ${result.derivatives.length} files`,
      );
      // TODO: Update photo status to 'ready' in database (Phase 4)
    });
    ```

Update `src/infrastructure/jobs/index.ts`:

- Add export for imageWorker from workers/imageProcessor
  </action>
  <verify>
- `npm run typecheck` passes
- `npm run lint` passes
- File exists at src/infrastructure/jobs/workers/imageProcessor.ts
- imageWorker exported and typed correctly
- Error handlers attached for 'error', 'failed', 'completed' events
  </verify>
  <done>
  Worker processes jobs with concurrency limit of 2, updates progress, logs events, and has error handlers.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create worker entry point with graceful shutdown</name>
  <files>
src/infrastructure/jobs/worker.ts
package.json
  </files>
  <action>
Create `src/infrastructure/jobs/worker.ts`:

1. Import imageWorker from ./workers/imageProcessor
2. Import imageQueue from ./queues

3. Log startup:

   ```typescript
   console.log("[Worker] Starting image processing worker...");
   console.log("[Worker] Listening on queue: image-processing");
   ```

4. Implement graceful shutdown:

   ```typescript
   async function gracefulShutdown(signal: string): Promise<void> {
     console.log(`[Worker] Received ${signal}, closing gracefully...`);

     // Stop accepting new jobs, wait for current jobs to finish
     await imageWorker.close();
     await imageQueue.close();

     console.log("[Worker] Shutdown complete");
     process.exit(0);
   }

   process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
   process.on("SIGINT", () => gracefulShutdown("SIGINT"));
   ```

5. Handle uncaught errors:
   ```typescript
   process.on("unhandledRejection", (err) => {
     console.error("[Worker] Unhandled rejection:", err);
     gracefulShutdown("unhandledRejection");
   });
   ```

Update `package.json` scripts:

- Add `"worker": "npx tsx src/infrastructure/jobs/worker.ts"`
- Note: Using tsx for TypeScript execution without compilation step

The worker runs as a separate process from Next.js, connecting to the same Redis instance.
</action>
<verify>

- `npm run typecheck` passes
- `npm run lint` passes
- File exists at src/infrastructure/jobs/worker.ts
- package.json has "worker" script
- Graceful shutdown handlers registered for SIGTERM and SIGINT
  </verify>
  <done>
  Worker can be started with `npm run worker`, logs activity, and shuts down cleanly on termination signals.
  </done>
  </task>

</tasks>

<verification>
- TypeScript compiles: `npm run typecheck`
- Linting passes: `npm run lint`
- Worker script exists: `npm run worker --help` (or similar check)
- Graceful shutdown handlers in place
- Worker connects to same Redis as queue
</verification>

<success_criteria>

1. src/infrastructure/jobs/workers/imageProcessor.ts creates BullMQ worker
2. Worker uses generateDerivatives from imageService
3. Worker limits concurrency to 2 jobs
4. Worker has error/failed/completed event handlers
5. src/infrastructure/jobs/worker.ts is entry point with shutdown logic
6. package.json has "worker" npm script using tsx
7. Worker handles SIGTERM and SIGINT for clean shutdown
8. No type or lint errors
   </success_criteria>

<output>
After completion, create `.planning/phases/02-image-pipeline/02-03-SUMMARY.md`
</output>
