---
phase: 02-image-pipeline
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - src/infrastructure/jobs/workers/imageProcessor.ts
  - src/infrastructure/jobs/worker.ts
  - src/infrastructure/jobs/index.ts
  - scripts/test-image-pipeline.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Worker processes jobs from image-processing queue"
    - "Worker updates job progress during processing"
    - "Worker handles errors gracefully with logging"
    - "Worker shuts down cleanly on SIGTERM/SIGINT"
    - "Worker can be started via npm script"
    - "Pipeline can be tested end-to-end via test script"
  artifacts:
    - path: "src/infrastructure/jobs/workers/imageProcessor.ts"
      provides: "BullMQ worker for image processing jobs"
      exports: ["imageWorker"]
    - path: "src/infrastructure/jobs/worker.ts"
      provides: "Worker entry point with graceful shutdown"
      min_lines: 30
    - path: "scripts/test-image-pipeline.ts"
      provides: "End-to-end pipeline verification script"
      min_lines: 40
  key_links:
    - from: "src/infrastructure/jobs/workers/imageProcessor.ts"
      to: "src/infrastructure/services/imageService.ts"
      via: "generateDerivatives import"
      pattern: "generateDerivatives"
    - from: "src/infrastructure/jobs/workers/imageProcessor.ts"
      to: "src/infrastructure/jobs/queues.ts"
      via: "queue connection"
      pattern: "image-processing"
    - from: "scripts/test-image-pipeline.ts"
      to: "src/infrastructure/jobs/index.ts"
      via: "enqueueImageProcessing call"
      pattern: "enqueueImageProcessing"
---

<objective>
Create the BullMQ worker that processes image jobs, generates derivatives using the image service, and handles graceful shutdown. Also create a test script to verify the pipeline works end-to-end.

Purpose: Complete the async processing pipeline - worker picks up jobs, generates thumbnails, reports progress/completion. Test script validates the pipeline is wired correctly.
Output: Worker that can be run via `npm run worker` and processes images from the queue, plus verification script.
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-image-pipeline/02-RESEARCH.md
@.planning/phases/02-image-pipeline/02-01-SUMMARY.md
@.planning/phases/02-image-pipeline/02-02-SUMMARY.md

# Prior implementations

@src/infrastructure/jobs/queues.ts
@src/infrastructure/services/imageService.ts
@src/infrastructure/config/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create image processor worker</name>
  <files>
src/infrastructure/jobs/workers/imageProcessor.ts
src/infrastructure/jobs/index.ts
  </files>
  <action>
Create `src/infrastructure/jobs/workers/imageProcessor.ts`:

1. Import Worker and Job from bullmq
2. Import IORedis from ioredis
3. Import path from path
4. Import sharp from sharp
5. Import { env } from @/infrastructure/config/env
6. Import { generateDerivatives } from @/infrastructure/services/imageService
7. Import { ImageJobData, ImageJobResult } from ../queues

8. Create Redis connection (same pattern as queues.ts):
   - `new IORedis(env.REDIS_URL, { maxRetriesPerRequest: null })`

9. Disable Sharp cache for long-running worker:
   - `sharp.cache(false)` - prevents memory buildup

10. Create and export `imageWorker`:

    ```typescript
    export const imageWorker = new Worker<ImageJobData, ImageJobResult>(
      "image-processing",
      async (job: Job<ImageJobData>) => {
        const { photoId, originalPath } = job.data;
        const outputDir = path.join(env.STORAGE_PATH, "processed", photoId);

        console.log(
          `[ImageWorker] Processing job ${job.id} for photo ${photoId}`,
        );

        // Update progress
        await job.updateProgress(10);

        // Generate all derivatives
        const derivatives = await generateDerivatives(originalPath, outputDir);

        await job.updateProgress(100);

        console.log(
          `[ImageWorker] Generated ${derivatives.length} files for photo ${photoId}`,
        );

        return { photoId, derivatives };
      },
      {
        connection,
        concurrency: 2, // Limit concurrent jobs (50MP images use ~144MB each)
      },
    );
    ```

11. Attach error handlers (CRITICAL - worker fails silently without these):

    ```typescript
    imageWorker.on("error", (err) => {
      console.error("[ImageWorker] Error:", err);
    });

    imageWorker.on("failed", (job, err) => {
      console.error(`[ImageWorker] Job ${job?.id} failed:`, err.message);
      // TODO: Update photo status to 'error' in database (Phase 4)
    });

    imageWorker.on("completed", (job, result) => {
      console.log(
        `[ImageWorker] Job ${job.id} completed: ${result.derivatives.length} files`,
      );
      // TODO: Update photo status to 'ready' in database (Phase 4)
    });
    ```

Update `src/infrastructure/jobs/index.ts`:

- Add export for imageWorker from workers/imageProcessor
  </action>
  <verify>
- `npm run typecheck` passes
- `npm run lint` passes
- File exists at src/infrastructure/jobs/workers/imageProcessor.ts
- imageWorker exported and typed correctly
- Error handlers attached for 'error', 'failed', 'completed' events
  </verify>
  <done>
  Worker processes jobs with concurrency limit of 2, updates progress, logs events, and has error handlers.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create worker entry point with graceful shutdown</name>
  <files>
src/infrastructure/jobs/worker.ts
package.json
  </files>
  <action>
Create `src/infrastructure/jobs/worker.ts`:

1. Import imageWorker from ./workers/imageProcessor
2. Import imageQueue from ./queues

3. Log startup:

   ```typescript
   console.log("[Worker] Starting image processing worker...");
   console.log("[Worker] Listening on queue: image-processing");
   ```

4. Implement graceful shutdown:

   ```typescript
   async function gracefulShutdown(signal: string): Promise<void> {
     console.log(`[Worker] Received ${signal}, closing gracefully...`);

     // Stop accepting new jobs, wait for current jobs to finish
     await imageWorker.close();
     await imageQueue.close();

     console.log("[Worker] Shutdown complete");
     process.exit(0);
   }

   process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
   process.on("SIGINT", () => gracefulShutdown("SIGINT"));
   ```

5. Handle uncaught errors:
   ```typescript
   process.on("unhandledRejection", (err) => {
     console.error("[Worker] Unhandled rejection:", err);
     gracefulShutdown("unhandledRejection");
   });
   ```

Update `package.json` scripts:

- Add `"worker": "npx tsx src/infrastructure/jobs/worker.ts"`
- Note: Using tsx for TypeScript execution without compilation step

The worker runs as a separate process from Next.js, connecting to the same Redis instance.
</action>
<verify>

- `npm run typecheck` passes
- `npm run lint` passes
- File exists at src/infrastructure/jobs/worker.ts
- package.json has "worker" script
- Graceful shutdown handlers registered for SIGTERM and SIGINT
  </verify>
  <done>
  Worker can be started with `npm run worker`, logs activity, and shuts down cleanly on termination signals.
  </done>
  </task>

<task type="auto">
  <name>Task 3: Create pipeline verification script</name>
  <files>
scripts/test-image-pipeline.ts
package.json
  </files>
  <action>
Create `scripts/test-image-pipeline.ts`:

1. Import enqueueImageProcessing from @/infrastructure/jobs
2. Import path and fs/promises
3. Import { env } from @/infrastructure/config/env

4. Create test image setup:
   - Define TEST_PHOTO_ID (e.g., "test-pipeline-" + Date.now())
   - Define test image path in storage/originals/{TEST_PHOTO_ID}/
   - Check if a sample image exists, or log instructions for placing one

5. Enqueue job:
   - Call enqueueImageProcessing(TEST_PHOTO_ID, originalPath)
   - Log the job ID returned

6. Wait for completion:
   - Poll the derivatives directory every 2 seconds
   - Check for 8 files (4 sizes x 2 formats: sm/md/lg/xl in webp/avif)
   - Timeout after 30 seconds with failure message

7. Report results:
   - On success: Log list of generated derivative files
   - On timeout: Log failure message with diagnostics

8. Cleanup:
   - Close queue connection to allow script to exit

Example structure:

```typescript
import { enqueueImageProcessing, imageQueue } from "@/infrastructure/jobs";
import { env } from "@/infrastructure/config/env";
import * as fs from "fs/promises";
import * as path from "path";

const TEST_PHOTO_ID = `test-pipeline-${Date.now()}`;

async function main() {
  const originalDir = path.join(env.STORAGE_PATH, "originals", TEST_PHOTO_ID);
  const derivativesDir = path.join(
    env.STORAGE_PATH,
    "processed",
    TEST_PHOTO_ID,
  );

  // Check for test image
  const testImagePath = path.join(originalDir, "original.jpg");
  try {
    await fs.access(testImagePath);
  } catch {
    console.log(`[Test] No test image found. Please place an image at:`);
    console.log(`       ${testImagePath}`);
    console.log(`[Test] Creating directory...`);
    await fs.mkdir(originalDir, { recursive: true });
    await imageQueue.close();
    process.exit(1);
  }

  console.log(`[Test] Enqueueing job for photo: ${TEST_PHOTO_ID}`);
  const job = await enqueueImageProcessing(TEST_PHOTO_ID, testImagePath);
  console.log(`[Test] Job enqueued with ID: ${job.id}`);

  // Poll for completion
  const EXPECTED_FILES = 8; // 4 sizes x 2 formats
  const POLL_INTERVAL = 2000;
  const TIMEOUT = 30000;
  const startTime = Date.now();

  while (Date.now() - startTime < TIMEOUT) {
    try {
      const files = await fs.readdir(derivativesDir);
      console.log(`[Test] Found ${files.length}/${EXPECTED_FILES} files...`);

      if (files.length >= EXPECTED_FILES) {
        console.log(`[Test] SUCCESS! Generated derivatives:`);
        files.forEach((f) => console.log(`       - ${f}`));
        await imageQueue.close();
        process.exit(0);
      }
    } catch {
      // Directory doesn't exist yet
    }

    await new Promise((r) => setTimeout(r, POLL_INTERVAL));
  }

  console.error(
    `[Test] TIMEOUT: Expected ${EXPECTED_FILES} files but did not complete in ${TIMEOUT / 1000}s`,
  );
  console.error(`[Test] Ensure worker is running: npm run worker`);
  await imageQueue.close();
  process.exit(1);
}

main().catch(console.error);
```

Note: Requires Redis and worker to be running (docker-compose up -d, npm run worker)

Update `package.json` scripts:

- Add `"test:pipeline": "npx tsx scripts/test-image-pipeline.ts"`
  </action>
  <verify>
- File exists at scripts/test-image-pipeline.ts
- Script imports enqueueImageProcessing from @/infrastructure/jobs
- Script calls enqueueImageProcessing()
- npm run typecheck passes
- package.json has "test:pipeline" script
  </verify>
  <done>
  Test script created that manually enqueues a job and verifies derivatives are generated, providing end-to-end pipeline verification.
  </done>
  </task>

</tasks>

<verification>
- TypeScript compiles: `npm run typecheck`
- Linting passes: `npm run lint`
- Worker script exists: `npm run worker --help` (or similar check)
- Graceful shutdown handlers in place
- Worker connects to same Redis as queue
- Test script can enqueue jobs and verify output
</verification>

<success_criteria>

1. src/infrastructure/jobs/workers/imageProcessor.ts creates BullMQ worker
2. Worker uses generateDerivatives from imageService
3. Worker limits concurrency to 2 jobs
4. Worker has error/failed/completed event handlers
5. src/infrastructure/jobs/worker.ts is entry point with shutdown logic
6. package.json has "worker" npm script using tsx
7. Worker handles SIGTERM and SIGINT for clean shutdown
8. scripts/test-image-pipeline.ts enqueues job and verifies derivatives
9. package.json has "test:pipeline" npm script
10. No type or lint errors
    </success_criteria>

<output>
After completion, create `.planning/phases/02-image-pipeline/02-03-SUMMARY.md`
</output>
