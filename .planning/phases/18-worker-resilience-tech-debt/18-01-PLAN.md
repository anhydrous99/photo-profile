---
phase: 18-worker-resilience-tech-debt
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/infrastructure/jobs/workers/imageProcessor.ts
  - src/domain/repositories/PhotoRepository.ts
  - src/infrastructure/database/repositories/SQLitePhotoRepository.ts
  - src/infrastructure/storage/fileStorage.ts
  - src/infrastructure/storage/index.ts
autonomous: true

must_haves:
  truths:
    - "Worker DB status update to 'ready' happens inside the processor function, covered by BullMQ 3-attempt retry"
    - "Worker DB status update to 'error' in the failed handler has explicit retry logic (try/catch with retry)"
    - "Repository has findByStatus() method that returns photos filtered by a given status"
    - "Repository has findStaleProcessing() method that returns photos stuck in 'processing' beyond a time threshold"
    - "A helper function can discover the original file path for a given photoId from the storage directory"
  artifacts:
    - path: "src/infrastructure/jobs/workers/imageProcessor.ts"
      provides: "Resilient worker with in-processor DB updates"
      contains: "repository.save"
    - path: "src/domain/repositories/PhotoRepository.ts"
      provides: "findByStatus and findStaleProcessing interface methods"
      contains: "findByStatus"
    - path: "src/infrastructure/database/repositories/SQLitePhotoRepository.ts"
      provides: "SQLite implementation of new query methods"
      contains: "findStaleProcessing"
    - path: "src/infrastructure/storage/fileStorage.ts"
      provides: "findOriginalFile helper for reprocess path discovery"
      contains: "findOriginalFile"
  key_links:
    - from: "src/infrastructure/jobs/workers/imageProcessor.ts"
      to: "src/infrastructure/database/repositories/SQLitePhotoRepository.ts"
      via: "repository.save() inside processor function"
      pattern: "repository\\.save"
    - from: "src/infrastructure/database/repositories/SQLitePhotoRepository.ts"
      to: "src/infrastructure/database/schema.ts"
      via: "Drizzle where clause with eq/lt operators"
      pattern: "eq\\(photos\\.status"
---

<objective>
Refactor the BullMQ image worker to move critical DB status updates inside the processor function (covered by BullMQ retry), add repository query methods for status filtering and stale detection, and add a file discovery helper for reprocessing.

Purpose: Photos currently can get permanently stuck in "processing" if the worker crashes between job completion and the event handler DB update. Moving the update inside the processor ensures BullMQ's 3-attempt retry covers it. The new repo methods and file helper are needed by Plan 18-02's admin UI.

Output: Resilient worker, two new PhotoRepository methods, one new storage helper.
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-worker-resilience-tech-debt/18-RESEARCH.md

@src/infrastructure/jobs/workers/imageProcessor.ts
@src/infrastructure/jobs/queues.ts
@src/domain/repositories/PhotoRepository.ts
@src/infrastructure/database/repositories/SQLitePhotoRepository.ts
@src/infrastructure/database/schema.ts
@src/infrastructure/storage/fileStorage.ts
@src/infrastructure/storage/index.ts
@src/domain/entities/Photo.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor imageProcessor to move DB updates into processor function</name>
  <files>src/infrastructure/jobs/workers/imageProcessor.ts</files>
  <action>
Move the DB status update from the `completed` event handler INTO the processor function itself, so it is covered by BullMQ's automatic retry mechanism (3 attempts with exponential backoff).

**In the processor function** (the async callback passed to `new Worker`), after generating derivatives/blur/exif/dimensions and before `return`:

1. Import and instantiate `SQLitePhotoRepository`
2. Find the photo by `photoId`
3. If found, set `photo.status = "ready"`, `photo.blurDataUrl = blurDataUrl`, `photo.exifData = exifData`, `photo.width = width`, `photo.height = height`, `photo.updatedAt = new Date()`
4. Call `await repository.save(photo)`
5. Log success: `[ImageWorker] Updated photo ${photoId} to 'ready'`

**In the `completed` event handler:**

- Remove ALL status-update and DB logic
- Keep ONLY the success log line: `console.log(\`[ImageWorker] Job ${job.id} completed: ${result.derivatives.length} files\`)`
- This prevents the race condition where both processor and event handler update status

**In the `failed` event handler:**

- Add explicit retry logic around the DB update. Wrap the existing status-to-error logic in a retry helper:
  ```
  async function retryDbUpdate(fn: () => Promise<void>, attempts = 3): Promise<void> {
    for (let i = 0; i < attempts; i++) {
      try { await fn(); return; } catch (err) {
        console.error(`[ImageWorker] DB update retry ${i + 1}/${attempts}:`, err);
        if (i < attempts - 1) await new Promise(r => setTimeout(r, 1000 * (i + 1)));
      }
    }
  }
  ```
- Use the retryDbUpdate wrapper when setting status to "error" in the failed handler
- The `failed` handler still makes sense for error status because it fires only after ALL BullMQ retry attempts are exhausted (final failure)
  </action>
  <verify>
  `npm run typecheck` passes. Review the imageProcessor.ts file to confirm:

1. Processor function contains `repository.save(photo)` with status="ready"
2. Completed handler has NO DB logic (only logging)
3. Failed handler has retry wrapper around DB update
   </verify>
   <done>
   DB status update to "ready" is inside the processor function (covered by BullMQ retry). Completed event handler only logs. Failed event handler has retry logic for its DB update.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Add findByStatus, findStaleProcessing repo methods and findOriginalFile helper</name>
  <files>
    src/domain/repositories/PhotoRepository.ts
    src/infrastructure/database/repositories/SQLitePhotoRepository.ts
    src/infrastructure/storage/fileStorage.ts
    src/infrastructure/storage/index.ts
  </files>
  <action>
**PhotoRepository interface** (`src/domain/repositories/PhotoRepository.ts`):
Add two new methods to the interface:
```typescript
findByStatus(status: Photo["status"]): Promise<Photo[]>;
findStaleProcessing(thresholdMs: number): Promise<Photo[]>;
```

**SQLitePhotoRepository** (`src/infrastructure/database/repositories/SQLitePhotoRepository.ts`):

1. Import `lt` from `drizzle-orm` (add to existing import)
2. Implement `findByStatus`:
   ```typescript
   async findByStatus(status: Photo["status"]): Promise<Photo[]> {
     const results = await db
       .select()
       .from(photos)
       .where(eq(photos.status, status));
     return results.map((row) => this.toDomain(row));
   }
   ```
3. Implement `findStaleProcessing`:
   ```typescript
   async findStaleProcessing(thresholdMs: number): Promise<Photo[]> {
     const cutoff = new Date(Date.now() - thresholdMs);
     const results = await db
       .select()
       .from(photos)
       .where(
         and(
           eq(photos.status, "processing"),
           lt(photos.createdAt, cutoff)
         )
       );
     return results.map((row) => this.toDomain(row));
   }
   ```
   Note: `and` is already imported. `lt` needs to be added to the existing drizzle-orm import.

**fileStorage.ts** (`src/infrastructure/storage/fileStorage.ts`):
Add a `findOriginalFile` function that discovers the original file path for a given photoId:

```typescript
import { readdir } from "fs/promises"; // add to existing imports

export async function findOriginalFile(
  photoId: string,
): Promise<string | null> {
  const dir = join(env.STORAGE_PATH, "originals", photoId);
  try {
    const files = await readdir(dir);
    const original = files.find((f) => f.startsWith("original."));
    return original ? join(dir, original) : null;
  } catch {
    return null; // Directory doesn't exist
  }
}
```

**storage/index.ts**: Add `findOriginalFile` to the barrel export.
</action>
<verify>
`npm run typecheck` passes. The PhotoRepository interface has both new methods. SQLitePhotoRepository implements them. fileStorage.ts exports findOriginalFile.
</verify>
<done>
PhotoRepository interface has findByStatus() and findStaleProcessing(). SQLitePhotoRepository implements both with Drizzle queries. fileStorage exports findOriginalFile() for discovering original file paths.
</done>
</task>

</tasks>

<verification>
1. `npm run typecheck` passes with no new errors
2. `npm run lint` passes
3. imageProcessor.ts processor function contains `repository.save(photo)` with `photo.status = "ready"`
4. imageProcessor.ts completed handler has no DB access
5. imageProcessor.ts failed handler has retry wrapper
6. PhotoRepository interface includes findByStatus and findStaleProcessing
7. SQLitePhotoRepository implements both methods
8. fileStorage.ts exports findOriginalFile
</verification>

<success_criteria>

- Worker processor function performs its own DB updates (covered by BullMQ retry)
- Event handlers are either logging-only (completed) or have retry logic (failed)
- Two new repository query methods available for admin filtering and stale detection
- Original file discovery helper available for reprocessing flow
- All type checks pass
  </success_criteria>

<output>
After completion, create `.planning/phases/18-worker-resilience-tech-debt/18-01-SUMMARY.md`
</output>
