---
phase: 18-worker-resilience-tech-debt
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - src/app/api/admin/photos/[id]/reprocess/route.ts
  - src/app/admin/(protected)/page.tsx
  - src/app/admin/(protected)/AdminDashboardClient.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can filter the photo list by status ('all', 'processing', 'ready', 'error') using a dropdown"
    - "Photos stuck in processing beyond 30 minutes are visually flagged as stale in the admin dashboard"
    - "Admin can click a 'Reprocess' button on a failed or stale photo, and it re-enters the processing pipeline"
    - "Reprocess endpoint validates auth, checks photo exists, resets status, and re-enqueues the job"
  artifacts:
    - path: "src/app/api/admin/photos/[id]/reprocess/route.ts"
      provides: "POST endpoint for reprocessing a photo"
      exports: ["POST"]
    - path: "src/app/admin/(protected)/page.tsx"
      provides: "Server component passing stale photo IDs to client"
      contains: "findStaleProcessing"
    - path: "src/app/admin/(protected)/AdminDashboardClient.tsx"
      provides: "Client component with status filter dropdown and reprocess button"
      contains: "statusFilter"
  key_links:
    - from: "src/app/admin/(protected)/AdminDashboardClient.tsx"
      to: "/api/admin/photos/[id]/reprocess"
      via: "fetch POST on reprocess button click"
      pattern: "fetch.*reprocess"
    - from: "src/app/api/admin/photos/[id]/reprocess/route.ts"
      to: "src/infrastructure/jobs/queues.ts"
      via: "enqueueImageProcessing after removing old job"
      pattern: "enqueueImageProcessing"
    - from: "src/app/admin/(protected)/page.tsx"
      to: "src/infrastructure/database/repositories/SQLitePhotoRepository.ts"
      via: "findStaleProcessing query"
      pattern: "findStaleProcessing"
---

<objective>
Add admin UI controls for filtering photos by status, visual stale-processing indicators, and a reprocess API endpoint so the admin can identify and recover stuck/failed photos.

Purpose: Without visibility into processing status and a reprocess mechanism, the admin has no way to discover or recover photos stuck in "processing" or "error" states. This plan provides the complete admin workflow: filter, identify, and fix.

Output: Status filter dropdown on dashboard, stale-photo visual flags, reprocess button, and POST API endpoint.
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-worker-resilience-tech-debt/18-RESEARCH.md
@.planning/phases/18-worker-resilience-tech-debt/18-01-SUMMARY.md

@src/app/admin/(protected)/page.tsx
@src/app/admin/(protected)/AdminDashboardClient.tsx
@src/app/api/admin/photos/[id]/route.ts
@src/infrastructure/jobs/queues.ts
@src/infrastructure/storage/fileStorage.ts
@src/infrastructure/auth/index.ts
@src/domain/entities/Photo.ts
@src/presentation/components/PhotoGrid.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reprocess API endpoint</name>
  <files>src/app/api/admin/photos/[id]/reprocess/route.ts</files>
  <action>
Create a new POST endpoint at `src/app/api/admin/photos/[id]/reprocess/route.ts`.

Follow the exact same patterns as the existing `src/app/api/admin/photos/[id]/route.ts` for auth checks, error handling, and response format.

```typescript
import { NextRequest, NextResponse } from "next/server";
import { verifySession } from "@/infrastructure/auth";
import { findOriginalFile } from "@/infrastructure/storage";
import { imageQueue, enqueueImageProcessing } from "@/infrastructure/jobs";
import { SQLitePhotoRepository } from "@/infrastructure/database/repositories";

const photoRepository = new SQLitePhotoRepository();

interface RouteContext {
  params: Promise<{ id: string }>;
}

export async function POST(_request: NextRequest, context: RouteContext) {
  try {
    // 1. Verify admin session
    const session = await verifySession();
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Get photo ID
    const { id } = await context.params;

    // 3. Fetch photo
    const photo = await photoRepository.findById(id);
    if (!photo) {
      return NextResponse.json({ error: "Photo not found" }, { status: 404 });
    }

    // 4. Only allow reprocessing of error or processing (stale) photos
    if (photo.status === "ready") {
      return NextResponse.json(
        { error: "Photo is already processed" },
        { status: 400 },
      );
    }

    // 5. Find original file
    const originalPath = await findOriginalFile(id);
    if (!originalPath) {
      return NextResponse.json(
        { error: "Original file not found" },
        { status: 404 },
      );
    }

    // 6. Reset photo status
    photo.status = "processing";
    photo.updatedAt = new Date();
    await photoRepository.save(photo);

    // 7. Remove old job (prevents job ID collision) and re-enqueue
    try {
      const oldJobId = `photo-${id}`;
      const oldJob = await imageQueue.getJob(oldJobId);
      if (oldJob) {
        await oldJob.remove();
      }
    } catch {
      // Old job may not exist or already removed - safe to ignore
    }

    try {
      await Promise.race([
        enqueueImageProcessing(id, originalPath),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error("Job enqueue timeout")), 10000),
        ),
      ]);
    } catch (enqueueError) {
      console.error(
        `[Reprocess] Failed to enqueue for photo ${id}:`,
        enqueueError instanceof Error ? enqueueError.message : enqueueError,
      );
      // Status already set to "processing" - will appear as stale if worker never picks it up
    }

    return NextResponse.json({ id, status: "processing" });
  } catch (error) {
    console.error("[API] POST /api/admin/photos/[id]/reprocess:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 },
    );
  }
}
```

Key design decisions:

- Remove old BullMQ job before re-enqueuing to avoid job ID collision (Pitfall 1 from research)
- Use same timeout pattern as upload route for Redis resilience
- Block reprocessing of "ready" photos (400 error) -- only error/processing allowed
- Use `findOriginalFile` from 18-01 to discover original file path
  </action>
  <verify>
  `npm run typecheck` passes. The route file exports a POST function. Verify auth check, photo existence check, status guard, job removal, and re-enqueue are all present.
  </verify>
  <done>
  POST /api/admin/photos/[id]/reprocess endpoint validates auth, checks photo exists, prevents reprocessing ready photos, discovers original file, removes old job, resets status, and re-enqueues processing.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Add status filter and reprocess controls to admin dashboard</name>
  <files>
    src/app/admin/(protected)/page.tsx
    src/app/admin/(protected)/AdminDashboardClient.tsx
  </files>
  <action>
**page.tsx** (Server Component):
1. In addition to `photoRepository.findAll()`, also call `photoRepository.findStaleProcessing(30 * 60 * 1000)` (30-minute threshold)
2. Extract stale photo IDs into a `Set<string>` and pass them as `stalePhotoIds: string[]` to `AdminDashboardClient`
3. Update the Props: `<AdminDashboardClient photos={sortedPhotos} albums={albums} stalePhotoIds={stalePhotoIds} />`

```typescript
const STALE_THRESHOLD_MS = 30 * 60 * 1000; // 30 minutes

const [photos, albums, stalePhotos] = await Promise.all([
  photoRepository.findAll(),
  albumRepository.findAll(),
  photoRepository.findStaleProcessing(STALE_THRESHOLD_MS),
]);

const stalePhotoIds = stalePhotos.map((p) => p.id);
```

**AdminDashboardClient.tsx** (Client Component):

1. Update props interface to accept `stalePhotoIds: string[]`
2. Add `statusFilter` state: `useState<"all" | "processing" | "ready" | "error">("all")`
3. Add a status filter dropdown above the PhotoGrid:

   ```
   <select value={statusFilter} onChange={...} className="rounded-lg border border-border px-3 py-1.5 text-sm bg-surface text-text-primary">
     <option value="all">All statuses</option>
     <option value="processing">Processing</option>
     <option value="ready">Ready</option>
     <option value="error">Error</option>
   </select>
   ```

   Place this in a flex row between the "Photos (N)" heading area and the PhotoGrid. Show a count of filtered results.

4. Compute `filteredPhotos`: if statusFilter is "all", show all photos. Otherwise, filter by `photo.status === statusFilter`.

5. Add a `handleReprocess` async function:

   ```typescript
   const handleReprocess = async (photoId: string) => {
     try {
       const res = await fetch(`/api/admin/photos/${photoId}/reprocess`, {
         method: "POST",
       });
       if (!res.ok) {
         const data = await res.json();
         alert(data.error || "Reprocess failed");
         return;
       }
       router.refresh();
     } catch {
       alert("Failed to reprocess photo");
     }
   };
   ```

6. Pass `stalePhotoIds` and `onReprocess={handleReprocess}` down to PhotoGrid. Since PhotoGrid already shows `StatusBadge`, we need to conditionally render a "Reprocess" button. However, to avoid heavily modifying the shared PhotoGrid component, instead render a reprocess toolbar/section:

   **Alternative approach (simpler):** Below the filter dropdown, add a section that shows actionable cards for photos with status "error" or stale "processing". This keeps the reprocess control separate from PhotoGrid:

   Actually, the simplest approach: Pass `filteredPhotos` to PhotoGrid (it already shows StatusBadge). Add a separate action bar that appears when any non-ready photos exist with a "Reprocess Selected" button or individual reprocess buttons.

   **Recommended approach:** Add individual reprocess buttons inline. Pass `onReprocess` and `stalePhotoIds` as new optional props to AdminDashboardClient. Below the filter dropdown and above PhotoGrid, render a small notification bar if there are stale or error photos:

   ```
   {(stalePhotoIds.length > 0 || filteredPhotos.some(p => p.status === "error")) && (
     <div className="mb-4 rounded-lg border border-yellow-500/30 bg-yellow-500/10 p-3 text-sm text-yellow-700 dark:text-yellow-400">
       {stalePhotoIds.length > 0 && <p>{stalePhotoIds.length} photo(s) stuck in processing (>30 min)</p>}
       {photos.filter(p => p.status === "error").length > 0 && <p>{photos.filter(p => p.status === "error").length} photo(s) failed processing</p>}
     </div>
   )}
   ```

   For the reprocess action, add it to the individual photo detail flow: when a user clicks a photo with error/stale status, they navigate to `/admin/photos/${photoId}` where they can see details. But for quick action, add a "Reprocess All Failed" button in the notification bar:

   ```typescript
   const handleReprocessAll = async () => {
     const targetPhotos = photos.filter(
       (p) => p.status === "error" || stalePhotoIds.includes(p.id),
     );
     for (const photo of targetPhotos) {
       await handleReprocess(photo.id);
     }
   };
   ```

   And a "Reprocess" button: `<button onClick={handleReprocessAll} className="mt-2 rounded-lg bg-accent px-3 py-1 text-xs font-medium text-white hover:bg-blue-700">Reprocess All</button>`

7. Pass `filteredPhotos` instead of `photos` to PhotoGrid.
   </action>
   <verify>
   `npm run typecheck` passes. `npm run lint` passes. Verify:
8. page.tsx calls findStaleProcessing and passes stalePhotoIds to client
9. AdminDashboardClient has status filter dropdown
10. AdminDashboardClient filters photos based on selected status
11. Notification bar appears for stale/error photos
12. Reprocess button exists and calls the API endpoint
    </verify>
    <done>
    Admin dashboard has a status filter dropdown. Photos are filterable by processing/ready/error status. Stale photos (>30min processing) are flagged with a notification bar. Admin can trigger reprocessing of all failed/stale photos with a single button, which calls the reprocess API endpoint and refreshes the page.
    </done>
    </task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. `npm run lint` passes
3. POST /api/admin/photos/[id]/reprocess endpoint exists with auth, validation, job removal, and re-enqueue
4. Admin dashboard has status filter dropdown with all/processing/ready/error options
5. Admin dashboard shows notification for stale and error photos
6. Reprocess button calls API and triggers page refresh
7. Filtered photo count updates when filter changes
</verification>

<success_criteria>

- Admin can filter photo list by status (processing, ready, error, all)
- Stale photos (processing >30 min) are visually flagged in the dashboard
- Admin can trigger reprocessing of failed/stale photos
- Reprocess endpoint handles auth, guards against reprocessing ready photos, resolves original file, removes old job, re-enqueues
- All type checks and lint pass
  </success_criteria>

<output>
After completion, create `.planning/phases/18-worker-resilience-tech-debt/18-02-SUMMARY.md`
</output>
