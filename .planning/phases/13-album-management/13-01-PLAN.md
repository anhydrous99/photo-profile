---
phase: 13-album-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/infrastructure/database/client.ts
  - src/domain/repositories/PhotoRepository.ts
  - src/infrastructure/database/repositories/SQLitePhotoRepository.ts
  - src/app/api/admin/albums/[id]/photos/reorder/route.ts
autonomous: true

must_haves:
  truths:
    - "findByAlbumId() returns photos ordered by sortOrder ascending"
    - "Adding a photo to an album assigns it the next sortOrder (not 0)"
    - "Reorder API persists new photo order within an album"
    - "coverPhotoId FK constraint is ON DELETE SET NULL (not NO ACTION)"
  artifacts:
    - path: "src/infrastructure/database/client.ts"
      provides: "FK constraint migration and foreign_keys pragma"
      contains: "ON DELETE SET NULL"
    - path: "src/infrastructure/database/repositories/SQLitePhotoRepository.ts"
      provides: "updatePhotoSortOrders method, fixed findByAlbumId, fixed addToAlbum"
      exports: ["SQLitePhotoRepository"]
    - path: "src/domain/repositories/PhotoRepository.ts"
      provides: "updatePhotoSortOrders interface method"
      contains: "updatePhotoSortOrders"
    - path: "src/app/api/admin/albums/[id]/photos/reorder/route.ts"
      provides: "POST endpoint for photo reorder"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/admin/albums/[id]/photos/reorder/route.ts"
      to: "SQLitePhotoRepository.updatePhotoSortOrders"
      via: "direct method call"
      pattern: "updatePhotoSortOrders"
    - from: "src/infrastructure/database/repositories/SQLitePhotoRepository.ts"
      to: "photoAlbums.sortOrder"
      via: "orderBy in findByAlbumId"
      pattern: "orderBy.*sortOrder"
---

<objective>
Fix infrastructure bugs in the album/photo data layer and add the photo reorder API endpoint.

Purpose: This plan fixes three known bugs (coverPhotoId FK constraint, missing ORDER BY in findByAlbumId, hardcoded sortOrder in addToAlbum) and adds the repository method + API endpoint needed for photo reordering within albums. These are prerequisites for the admin album detail UI in Plan 02.

Output: Fixed database layer, new `updatePhotoSortOrders` repository method, and `POST /api/admin/albums/[id]/photos/reorder` API endpoint.
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-album-management/13-RESEARCH.md
@src/infrastructure/database/client.ts
@src/infrastructure/database/schema.ts
@src/domain/repositories/PhotoRepository.ts
@src/infrastructure/database/repositories/SQLitePhotoRepository.ts
@src/app/api/admin/albums/reorder/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix infrastructure bugs (FK constraint, ORDER BY, sortOrder)</name>
  <files>
    src/infrastructure/database/client.ts
    src/infrastructure/database/repositories/SQLitePhotoRepository.ts
  </files>
  <action>
    **In `src/infrastructure/database/client.ts`** — Add a migration block inside `initializeDatabase()` after the existing Phase 12 migration (width/height columns). This migration must:

    1. Check if the coverPhotoId FK constraint needs fixing using `PRAGMA foreign_key_list(albums)`. Find the FK entry where `from === "cover_photo_id"`. If its `on_delete` is not `"SET NULL"`, run the table recreation.

    2. Table recreation (inside the conditional):
       - `sqlite.pragma("foreign_keys = OFF")`
       - Run a transaction that: renames `albums` to `_albums_old`, creates new `albums` table with correct `ON DELETE SET NULL` on `cover_photo_id`, copies data with `INSERT INTO albums SELECT id, title, description, tags, cover_photo_id, sort_order, is_published, created_at FROM _albums_old`, drops `_albums_old`.
       - **CRITICAL:** Include ALL columns: `id TEXT PRIMARY KEY, title TEXT NOT NULL, description TEXT, tags TEXT, cover_photo_id TEXT REFERENCES photos(id) ON DELETE SET NULL, sort_order INTEGER NOT NULL DEFAULT 0, is_published INTEGER NOT NULL DEFAULT 0, created_at INTEGER NOT NULL DEFAULT (unixepoch() * 1000)`. The `tags` column was added after initial creation and MUST be included.
       - `sqlite.pragma("foreign_keys = ON")`
       - Log: `[DB] Fixed coverPhotoId FK constraint to ON DELETE SET NULL`

    3. After ALL migrations (at the end of the try block, before catch), add: `sqlite.pragma("foreign_keys = ON")` to enable FK enforcement going forward. Log: `[DB] Foreign key enforcement enabled`.

    **In `src/infrastructure/database/repositories/SQLitePhotoRepository.ts`** — Two fixes:

    1. **Fix `findByAlbumId()`**: Add `.orderBy(photoAlbums.sortOrder)` to the query chain, right after the `.where()` clause. Import `asc` from `drizzle-orm` if needed, or just use `photoAlbums.sortOrder` directly (Drizzle defaults to ASC).

    2. **Fix `addToAlbum()`**: Instead of hardcoding `sortOrder: 0`, compute `MAX(sort_order) + 1` for the album. Query: `SELECT MAX(sort_order) as maxOrder FROM photo_albums WHERE album_id = ?`. If no rows, use 0. Then insert with that computed sortOrder. Use `db.select({ maxOrder: sql<number>`max(${photoAlbums.sortOrder})` }).from(photoAlbums).where(eq(photoAlbums.albumId, albumId))` to get the max, then set sortOrder to `(maxOrder ?? -1) + 1`.

  </action>
  <verify>
    Run `npm run typecheck` — no errors.
    Run `npm run lint` — no errors.
    Run `npm run build` — builds successfully.
  </verify>
  <done>
    - findByAlbumId() includes `.orderBy(photoAlbums.sortOrder)` in the query
    - addToAlbum() computes MAX(sort_order) + 1 instead of hardcoding 0
    - initializeDatabase() has migration to recreate albums table with ON DELETE SET NULL
    - Foreign keys are enabled via pragma at end of initializeDatabase()
  </done>
</task>

<task type="auto">
  <name>Task 2: Add updatePhotoSortOrders repository method and reorder API</name>
  <files>
    src/domain/repositories/PhotoRepository.ts
    src/infrastructure/database/repositories/SQLitePhotoRepository.ts
    src/app/api/admin/albums/[id]/photos/reorder/route.ts
  </files>
  <action>
    **In `src/domain/repositories/PhotoRepository.ts`** — Add method to the interface:
    ```
    updatePhotoSortOrders(albumId: string, photoIds: string[]): Promise<void>;
    ```

    **In `src/infrastructure/database/repositories/SQLitePhotoRepository.ts`** — Implement the new method. Use a transaction to update `photo_albums.sortOrder` for each photo in the array. `photoIds[0]` gets sortOrder 0, `photoIds[1]` gets sortOrder 1, etc. Pattern matches `SQLiteAlbumRepository.updateSortOrders()` exactly:
    ```typescript
    async updatePhotoSortOrders(albumId: string, photoIds: string[]): Promise<void> {
      await db.transaction(async (tx) => {
        for (let i = 0; i < photoIds.length; i++) {
          await tx
            .update(photoAlbums)
            .set({ sortOrder: i })
            .where(
              and(
                eq(photoAlbums.albumId, albumId),
                eq(photoAlbums.photoId, photoIds[i]),
              ),
            );
        }
      });
    }
    ```

    **Create `src/app/api/admin/albums/[id]/photos/reorder/route.ts`** — POST endpoint. Follow the exact pattern from `src/app/api/admin/albums/reorder/route.ts` (album reorder API):
    - Import `verifySession` from `@/infrastructure/auth`
    - Import `SQLitePhotoRepository` from `@/infrastructure/database/repositories`
    - Import `z` from `zod`
    - Zod schema: `{ photoIds: z.array(z.string()) }`
    - Auth check (401 if no session)
    - Parse `params.id` as albumId (use `context: { params: Promise<{ id: string }> }` pattern from the existing album PATCH route)
    - Validate body with zod (400 on failure)
    - Call `photoRepository.updatePhotoSortOrders(albumId, result.data.photoIds)`
    - Return `{ success: true }`

  </action>
  <verify>
    Run `npm run typecheck` — no errors.
    Run `npm run lint` — no errors.
    Run `npm run build` — builds successfully.
  </verify>
  <done>
    - PhotoRepository interface has updatePhotoSortOrders method
    - SQLitePhotoRepository implements updatePhotoSortOrders using transaction
    - POST /api/admin/albums/[id]/photos/reorder exists, validates auth + body, persists order
  </done>
</task>

</tasks>

<verification>
- `npm run typecheck` passes
- `npm run build` succeeds
- `npm run lint` passes
- The reorder API file exists at `src/app/api/admin/albums/[id]/photos/reorder/route.ts`
- The PhotoRepository interface includes `updatePhotoSortOrders`
- `findByAlbumId` query includes orderBy on sortOrder
- `addToAlbum` computes max sortOrder instead of hardcoding 0
- FK migration code is in `initializeDatabase()`
</verification>

<success_criteria>

1. All three infrastructure bugs are fixed (FK constraint, ORDER BY, addToAlbum sortOrder)
2. Photo reorder API endpoint exists and follows established patterns
3. Repository layer has updatePhotoSortOrders method on both interface and implementation
4. Build passes with no type errors
   </success_criteria>

<output>
After completion, create `.planning/phases/13-album-management/13-01-SUMMARY.md`
</output>
