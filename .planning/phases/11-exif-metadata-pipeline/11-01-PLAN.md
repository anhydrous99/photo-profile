---
phase: 11-exif-metadata-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/domain/entities/Photo.ts
  - src/infrastructure/database/schema.ts
  - src/infrastructure/database/client.ts
  - src/infrastructure/database/repositories/SQLitePhotoRepository.ts
  - src/infrastructure/services/exifService.ts
  - src/infrastructure/jobs/workers/imageProcessor.ts
  - src/infrastructure/jobs/queues.ts
autonomous: true

must_haves:
  truths:
    - "Uploading a new photo automatically extracts and stores EXIF metadata"
    - "GPS coordinates, camera serial numbers, and software/editor info are never stored"
    - "All EXIF fields are nullable (gracefully handles missing/corrupt EXIF)"
  artifacts:
    - path: "src/domain/entities/Photo.ts"
      provides: "ExifData interface and optional exifData field on Photo"
      contains: "ExifData"
    - path: "src/infrastructure/services/exifService.ts"
      provides: "EXIF extraction + privacy sanitization"
      exports: ["extractExifData"]
    - path: "src/infrastructure/database/schema.ts"
      provides: "exif_data TEXT column on photos table"
      contains: "exifData"
    - path: "src/infrastructure/database/client.ts"
      provides: "ALTER TABLE migration for exif_data column"
      contains: "exif_data"
    - path: "src/infrastructure/database/repositories/SQLitePhotoRepository.ts"
      provides: "JSON serialization/deserialization of exifData"
      contains: "exifData"
    - path: "src/infrastructure/jobs/workers/imageProcessor.ts"
      provides: "EXIF extraction during image processing"
      contains: "extractExifData"
  key_links:
    - from: "src/infrastructure/jobs/workers/imageProcessor.ts"
      to: "src/infrastructure/services/exifService.ts"
      via: "import and call extractExifData"
      pattern: "extractExifData"
    - from: "src/infrastructure/services/exifService.ts"
      to: "exif-reader"
      via: "npm dependency"
      pattern: "exif-reader"
    - from: "src/infrastructure/database/repositories/SQLitePhotoRepository.ts"
      to: "src/domain/entities/Photo.ts"
      via: "JSON.parse/stringify of exifData"
      pattern: "JSON\\.parse.*exif"
---

<objective>
Add EXIF metadata extraction, storage, and worker integration for the photo upload pipeline.

Purpose: When a new photo is uploaded and processed by the BullMQ worker, its EXIF metadata (camera, lens, focal length, aperture, shutter speed, ISO, date taken, white balance, metering mode, flash) is automatically extracted, sanitized (no GPS/serial/software), and stored as JSON in the database. This is the backend foundation that Plan 02 (display) and Plan 03 (backfill) build upon.

Output: ExifData type, exifService, schema migration, repository mapping, worker integration -- all wired so new uploads automatically get EXIF data.
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-exif-metadata-pipeline/11-CONTEXT.md
@.planning/phases/11-exif-metadata-pipeline/11-RESEARCH.md
@src/domain/entities/Photo.ts
@src/infrastructure/database/schema.ts
@src/infrastructure/database/client.ts
@src/infrastructure/database/repositories/SQLitePhotoRepository.ts
@src/infrastructure/services/imageService.ts
@src/infrastructure/jobs/workers/imageProcessor.ts
@src/infrastructure/jobs/queues.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ExifData type, exifService, and install exif-reader</name>
  <files>
    src/domain/entities/Photo.ts
    src/infrastructure/services/exifService.ts
    package.json
  </files>
  <action>
1. Install exif-reader: `npm install exif-reader`

2. In `src/domain/entities/Photo.ts`, add the ExifData interface and extend Photo:

```typescript
export interface ExifData {
  cameraMake: string | null;
  cameraModel: string | null;
  lens: string | null;
  focalLength: number | null; // in mm
  aperture: number | null; // f-number (e.g. 2.8)
  shutterSpeed: string | null; // formatted string (e.g. "1/250")
  iso: number | null;
  dateTaken: string | null; // ISO 8601 string
  whiteBalance: string | null; // "Auto", "Manual", etc.
  meteringMode: string | null; // "Matrix", "Center-weighted", etc.
  flash: string | null; // "Fired", "Did not fire", etc.
}

export interface Photo {
  // ... existing fields unchanged ...
  exifData: ExifData | null; // ADD this field
}
```

3. Create `src/infrastructure/services/exifService.ts`:
   - Import sharp and exif-reader (default import: `import exifReader from "exif-reader"`)
   - Export `extractExifData(imagePath: string): Promise<ExifData | null>`
   - Use `sharp(imagePath).metadata()` to get the raw EXIF buffer via `metadata.exif`
   - If no exif buffer, return null
   - Parse with `exifReader(metadata.exif)` inside try/catch
   - Map parsed fields to ExifData:
     - cameraMake: `parsed.Image?.Make` or `parsed?.Photo?.Make` (check both IFDs)
     - cameraModel: `parsed.Image?.Model` or `parsed?.Photo?.Model`
     - lens: `parsed.Photo?.LensModel` (or `parsed.Exif?.LensModel`)
     - focalLength: `parsed.Photo?.FocalLength` (number in mm)
     - aperture: `parsed.Photo?.FNumber` (number)
     - shutterSpeed: format from `parsed.Photo?.ExposureTime` -- if value < 1, format as `1/${Math.round(1/value)}`; if >= 1, format as `${value}s`; if null, null
     - iso: `parsed.Photo?.ISOSpeedRatings` (may be number or array, take first element if array)
     - dateTaken: `parsed.Photo?.DateTimeOriginal` -- if Date, call `.toISOString()`; if string, store as-is
     - whiteBalance: map from `parsed.Photo?.WhiteBalance` numeric code: 0="Auto", 1="Manual", else null
     - meteringMode: map from `parsed.Photo?.MeteringMode` numeric code: 0="Unknown", 1="Average", 2="Center-weighted average", 3="Spot", 4="Multi-spot", 5="Pattern", 6="Partial", else null
     - flash: map from `parsed.Photo?.Flash` numeric code using bit field: bit 0 = fired (0="Did not fire", 1="Fired"); for common values: 0="Did not fire", 1="Fired", 5="Fired, return not detected", 7="Fired, return detected", 9="Fired, compulsory", 16="Did not fire, compulsory", 24="Did not fire, auto", 25="Fired, auto", 32="No flash function", else check bit 0 for "Fired"/"Did not fire"
   - CRITICAL: Do NOT access, read, or store: GPS, GPSInfo, GPSLatitude, GPSLongitude, any GPS\* tags, BodySerialNumber, CameraSerialNumber, SerialNumber, Software, ProcessingSoftware, or any software/editor tags. Do not even read these fields -- skip them entirely.
   - All fields default to null on any parsing failure
   - Wrap entire parsing in try/catch, return null on any error
     </action>
     <verify>
     `npm run typecheck` passes. The ExifData interface exists in Photo.ts. exifService.ts exports extractExifData.
     </verify>
     <done>ExifData type defined with all 11 fields. exifService extracts EXIF from image files via sharp+exif-reader, formats shutter speed, maps enum codes, and excludes GPS/serial/software. All fields nullable for graceful degradation.</done>
     </task>

<task type="auto">
  <name>Task 2: Schema migration, repository mapping, and worker integration</name>
  <files>
    src/infrastructure/database/schema.ts
    src/infrastructure/database/client.ts
    src/infrastructure/database/repositories/SQLitePhotoRepository.ts
    src/infrastructure/jobs/workers/imageProcessor.ts
    src/infrastructure/jobs/queues.ts
  </files>
  <action>
1. In `src/infrastructure/database/schema.ts`, add `exifData` column to the `photos` table definition:
   ```typescript
   exifData: text("exif_data"),  // JSON-serialized ExifData
   ```
   Place after `blurDataUrl` and before `status`.

2. In `src/infrastructure/database/client.ts`, add an idempotent ALTER TABLE migration inside `initializeDatabase()` AFTER the CREATE TABLE statements (at the end of the try block, before catch). Use the project's established pattern (direct ALTER TABLE, NOT db:push):

   ```typescript
   // Migration: Add exif_data column (Phase 11)
   const tableInfo = sqlite
     .prepare("PRAGMA table_info(photos)")
     .all() as Array<{ name: string }>;
   const hasExifData = tableInfo.some((col) => col.name === "exif_data");
   if (!hasExifData) {
     sqlite.prepare("ALTER TABLE photos ADD COLUMN exif_data TEXT").run();
     console.log("[DB] Added exif_data column to photos table");
   }
   ```

   Note: Use the raw `sqlite` (better-sqlite3) instance for PRAGMA and ALTER TABLE, not the drizzle `db`.

3. In `src/infrastructure/database/repositories/SQLitePhotoRepository.ts`:
   - Update `toDomain()` to parse exif_data JSON:
     ```typescript
     exifData: row.exifData ? JSON.parse(row.exifData) : null,
     ```
   - Update `toDatabase()` to serialize exifData:
     ```typescript
     exifData: photo.exifData ? JSON.stringify(photo.exifData) : null,
     ```

4. In `src/infrastructure/jobs/queues.ts`, add `exifData` to `ImageJobResult`:

   ```typescript
   import type { ExifData } from "@/domain/entities/Photo";

   export interface ImageJobResult {
     photoId: string;
     derivatives: string[];
     blurDataUrl: string;
     exifData: ExifData | null; // ADD this
   }
   ```

5. In `src/infrastructure/jobs/workers/imageProcessor.ts`:
   - Import `extractExifData` from `@/infrastructure/services/exifService`
   - In the worker function, after generating derivatives and before generating blur placeholder, call:
     ```typescript
     const exifData = await extractExifData(originalPath);
     ```
   - Include `exifData` in the return value: `return { photoId, derivatives, blurDataUrl, exifData };`
   - In the `completed` event handler, after setting `photo.status = "ready"` and `photo.blurDataUrl = result.blurDataUrl`, add:
     `typescript
photo.exifData = result.exifData;
`
     </action>
     <verify>
     `npm run typecheck` passes. `npm run build` succeeds. Start dev server with `npm run dev` and confirm no runtime errors on page load (the migration runs on module load).
     </verify>
     <done>The photos table has an exif_data TEXT column (added via idempotent ALTER TABLE). The repository serializes/deserializes ExifData as JSON. The image processing worker extracts EXIF from originals during processing and stores it alongside blur data. New photo uploads will automatically have EXIF metadata persisted.</done>
     </task>

</tasks>

<verification>
1. `npm run typecheck` -- no type errors
2. `npm run build` -- successful production build
3. `npm run dev` -- dev server starts, migration runs without error
4. Photo entity has ExifData interface with 11 fields
5. exifService.ts exists and exports extractExifData
6. schema.ts has exifData column on photos table
7. client.ts has idempotent ALTER TABLE migration
8. SQLitePhotoRepository maps exifData via JSON parse/stringify
9. imageProcessor.ts calls extractExifData and includes result in job output
</verification>

<success_criteria>

- ExifData type exists with: cameraMake, cameraModel, lens, focalLength, aperture, shutterSpeed, iso, dateTaken, whiteBalance, meteringMode, flash
- GPS, serial number, and software tags are never accessed or stored
- New photo uploads through the worker pipeline extract and persist EXIF data
- Schema migration is idempotent (safe to run multiple times)
- All existing functionality (upload, view, admin) continues working
  </success_criteria>

<output>
After completion, create `.planning/phases/11-exif-metadata-pipeline/11-01-SUMMARY.md`
</output>
