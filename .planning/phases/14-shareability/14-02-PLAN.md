---
phase: 14-shareability
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/app/layout.tsx
  - src/app/page.tsx
  - src/app/albums/[id]/page.tsx
  - src/app/albums/[id]/photo/[slug]/page.tsx
  - src/app/photo/[slug]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Navigating to /albums/{albumId}/photo/{slug} opens the album page with lightbox showing that photo"
    - "Navigating to /photo/{slug} resolves the photo and shows it in context"
    - "Sharing an album URL shows title, description, and cover photo in social media preview"
    - "Sharing the homepage URL shows site name and description in social media preview"
    - "Sharing a photo deep link URL shows the photo as OG image with EXIF info in description"
    - "Navigating to a URL with an invalid slug returns 404"
  artifacts:
    - path: "src/app/layout.tsx"
      provides: "metadataBase and default OG tags"
      contains: "metadataBase"
    - path: "src/app/page.tsx"
      provides: "Homepage OG metadata"
      contains: "metadata"
    - path: "src/app/albums/[id]/page.tsx"
      provides: "Album OG metadata via generateMetadata"
      contains: "generateMetadata"
    - path: "src/app/albums/[id]/photo/[slug]/page.tsx"
      provides: "Album photo deep link page with OG tags"
      exports: ["default", "generateMetadata"]
    - path: "src/app/photo/[slug]/page.tsx"
      provides: "Homepage photo deep link page with OG tags"
      exports: ["default", "generateMetadata"]
  key_links:
    - from: "src/app/albums/[id]/photo/[slug]/page.tsx"
      to: "src/presentation/components/AlbumGalleryClient.tsx"
      via: "renders AlbumGalleryClient with initialPhotoSlug prop"
      pattern: "AlbumGalleryClient.*initialPhotoSlug"
    - from: "src/app/photo/[slug]/page.tsx"
      to: "src/presentation/components/HomepageClient.tsx"
      via: "renders HomepageClient with initialPhotoSlug prop"
      pattern: "HomepageClient.*initialPhotoSlug"
    - from: "src/app/albums/[id]/page.tsx"
      to: "SQLiteAlbumRepository"
      via: "generateMetadata fetches album for OG tags"
      pattern: "generateMetadata.*findById"
    - from: "src/app/layout.tsx"
      to: "metadataBase"
      via: "NEXT_PUBLIC_SITE_URL env var"
      pattern: "metadataBase.*NEXT_PUBLIC_SITE_URL"
---

<objective>
Create deep link pages and add OpenGraph meta tags across all public routes.

Purpose: Visitors can share direct links to specific photos (SHAR-02), and shared links produce rich preview cards on social media (SHAR-03, SHAR-04). Deep link pages resolve the photo slug, render the existing gallery with the lightbox pre-opened, and provide dynamic OG metadata.

Output: Two new page routes for photo deep links, OG metadata on all public pages, metadataBase in root layout.
</objective>

<execution_context>
@/Users/arxherre/.claude/get-shit-done/workflows/execute-plan.md
@/Users/arxherre/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-shareability/14-CONTEXT.md
@.planning/phases/14-shareability/14-RESEARCH.md
@.planning/phases/14-shareability/14-01-SUMMARY.md
@src/app/layout.tsx
@src/app/page.tsx
@src/app/albums/[id]/page.tsx
@src/presentation/components/AlbumGalleryClient.tsx
@src/presentation/components/HomepageClient.tsx
@src/domain/entities/Photo.ts
@src/domain/entities/Album.ts
@src/domain/repositories/PhotoRepository.ts
@src/infrastructure/database/repositories/SQLitePhotoRepository.ts
@src/infrastructure/database/repositories/SQLiteAlbumRepository.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add metadataBase to root layout and OG metadata to homepage and album pages</name>
  <files>
    src/app/layout.tsx
    src/app/page.tsx
    src/app/albums/[id]/page.tsx
  </files>
  <action>
  **src/app/layout.tsx:**

1. Update the existing static `metadata` export to include `metadataBase` and default OG tags:
   ```typescript
   export const metadata: Metadata = {
     metadataBase: new URL(
       process.env.NEXT_PUBLIC_SITE_URL || "http://localhost:3000",
     ),
     title: {
       default: process.env.NEXT_PUBLIC_SITE_NAME || "Portfolio",
       template: `%s | ${process.env.NEXT_PUBLIC_SITE_NAME || "Portfolio"}`,
     },
     description:
       process.env.NEXT_PUBLIC_SITE_DESCRIPTION || "A photography portfolio",
     openGraph: {
       type: "website",
       siteName: process.env.NEXT_PUBLIC_SITE_NAME || "Portfolio",
     },
     twitter: {
       card: "summary",
     },
   };
   ```
2. The `metadataBase` ensures all relative OG image URLs are resolved to absolute URLs automatically.
3. Use `title.template` so child pages can set just their title and get " | Portfolio" appended.

**src/app/page.tsx (homepage):**

1. Add a static metadata export for the homepage (SHAR-04). Since `page.tsx` already has `export const dynamic = "force-dynamic"`, static metadata still works fine (metadata is generated at request time for dynamic pages).
   ```typescript
   export const metadata: Metadata = {
     title: process.env.NEXT_PUBLIC_SITE_NAME || "Portfolio",
     description:
       process.env.NEXT_PUBLIC_SITE_DESCRIPTION || "A photography portfolio",
     openGraph: {
       title: process.env.NEXT_PUBLIC_SITE_NAME || "Portfolio",
       description:
         process.env.NEXT_PUBLIC_SITE_DESCRIPTION || "A photography portfolio",
       type: "website",
     },
     twitter: {
       card: "summary",
     },
   };
   ```
2. Import `Metadata` type from `next`.

**src/app/albums/[id]/page.tsx (album detail):**

1. Add a `generateMetadata` export function for dynamic album OG tags (SHAR-03):

   ```typescript
   export async function generateMetadata({
     params,
   }: PageProps): Promise<Metadata> {
     const { id } = await params;
     const albumRepo = new SQLiteAlbumRepository();
     const album = await albumRepo.findById(id);

     if (!album || !album.isPublished) {
       return { title: "Album Not Found" };
     }

     const metadata: Metadata = {
       title: album.title,
       description: album.description || `Photos from ${album.title}`,
       openGraph: {
         title: album.title,
         description: album.description || `Photos from ${album.title}`,
         type: "website",
       },
       twitter: {
         card: "summary_large_image",
       },
     };

     // Use cover photo or first photo as OG image
     if (album.coverPhotoId) {
       const ogImageUrl = `/api/images/${album.coverPhotoId}/1200w.webp`;
       metadata.openGraph!.images = [
         { url: ogImageUrl, width: 1200, type: "image/webp" },
       ];
       metadata.twitter!.images = [ogImageUrl];
     } else {
       // Fallback: use first ready photo from album
       const photoRepo = new SQLitePhotoRepository();
       const photos = await photoRepo.findByAlbumId(id);
       const firstReady = photos.find((p) => p.status === "ready");
       if (firstReady) {
         const ogImageUrl = `/api/images/${firstReady.id}/1200w.webp`;
         metadata.openGraph!.images = [
           { url: ogImageUrl, width: 1200, type: "image/webp" },
         ];
         metadata.twitter!.images = [ogImageUrl];
       }
     }

     return metadata;
   }
   ```

2. Import `Metadata` type from `next`.
3. The duplicate `albumRepo.findById` call in `generateMetadata` and the page function is fine -- Next.js App Router deduplicates fetch requests within a single render. For direct DB queries, use `import { cache } from "react"` to wrap the repository call and share it between generateMetadata and the page component. Create a cached helper at the top of the file:

   ```typescript
   import { cache } from "react";

   const getAlbum = cache(async (id: string) => {
     const albumRepo = new SQLiteAlbumRepository();
     return albumRepo.findById(id);
   });
   ```

   Then use `getAlbum(id)` in both `generateMetadata` and the page function instead of creating a new repo each time.

4. Use WebP (NOT AVIF) for OG images -- many social media crawlers don't support AVIF.
5. Use 1200w derivative -- ideal size for OG images without needing a custom crop.
   </action>
   <verify>
   Run `npm run typecheck` to confirm no type errors.
   Run `npm run build` to confirm the build succeeds.
   </verify>
   <done>

- Root layout has metadataBase set from NEXT_PUBLIC_SITE_URL with fallback to localhost:3000
- Homepage has static OG metadata with site name and description
- Album pages have dynamic OG metadata with album title, description, and cover photo image
- All OG image URLs resolve to absolute URLs via metadataBase
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create deep link pages for album photos and homepage photos</name>
  <files>
    src/app/albums/[id]/photo/[slug]/page.tsx
    src/app/photo/[slug]/page.tsx
  </files>
  <action>
  **src/app/albums/[id]/photo/[slug]/page.tsx (NEW):**

This page handles direct links to photos within an album context (e.g., `/albums/abc123/photo/a1b2c3d4`).

1. Create the file as a Server Component.
2. Define the page props interface:
   ```typescript
   interface PageProps {
     params: Promise<{ id: string; slug: string }>;
   }
   ```
3. Implement the page function:
   - Await params to get `id` (album ID) and `slug` (photo slug prefix)
   - Use the cached `getAlbum` pattern (same as Task 1's album page) to fetch the album
   - If album not found or not published, call `notFound()`
   - Fetch album photos via `SQLitePhotoRepository.findByAlbumId(id)`, filter to ready
   - Verify the slug matches a photo in this album: `photos.find(p => p.id.startsWith(slug))`
   - If no matching photo found, call `notFound()`
   - Render the same markup as the existing album page (Header + AlbumGalleryClient), but pass `initialPhotoSlug={slug}` to AlbumGalleryClient
   - Import Header from the same location the album page uses (check if album page uses Header -- it doesn't currently, so just render AlbumGalleryClient directly, same as the album page)

4. Add `generateMetadata` for photo-specific OG tags:

   ```typescript
   export async function generateMetadata({
     params,
   }: PageProps): Promise<Metadata> {
     const { id, slug } = await params;
     const albumRepo = new SQLiteAlbumRepository();
     const photoRepo = new SQLitePhotoRepository();

     const album = await albumRepo.findById(id);
     if (!album || !album.isPublished) {
       return { title: "Photo Not Found" };
     }

     const photo = await photoRepo.findBySlugPrefix(slug);
     if (!photo) {
       return { title: "Photo Not Found" };
     }

     // Build description from EXIF data if available
     let description = photo.description || `A photo from ${album.title}`;
     if (photo.exifData) {
       const exifParts: string[] = [];
       if (photo.exifData.cameraModel)
         exifParts.push(photo.exifData.cameraModel);
       if (photo.exifData.focalLength)
         exifParts.push(`${photo.exifData.focalLength}mm`);
       if (photo.exifData.aperture)
         exifParts.push(`f/${photo.exifData.aperture}`);
       if (photo.exifData.shutterSpeed)
         exifParts.push(photo.exifData.shutterSpeed);
       if (photo.exifData.iso) exifParts.push(`ISO ${photo.exifData.iso}`);
       if (exifParts.length > 0) {
         description = photo.description
           ? `${photo.description} — ${exifParts.join(" | ")}`
           : `${album.title} — ${exifParts.join(" | ")}`;
       }
     }

     const ogImageUrl = `/api/images/${photo.id}/1200w.webp`;

     return {
       title: photo.title || album.title,
       description,
       openGraph: {
         title: photo.title || album.title,
         description,
         type: "website",
         images: [{ url: ogImageUrl, width: 1200, type: "image/webp" }],
       },
       twitter: {
         card: "summary_large_image",
         title: photo.title || album.title,
         description,
         images: [ogImageUrl],
       },
     };
   }
   ```

5. The page content should closely mirror the existing `/albums/[id]/page.tsx` but with `initialPhotoSlug` passed through:
   - Fetch album and photos (same queries)
   - Render `<AlbumGalleryClient album={...} photos={...} initialPhotoSlug={slug} />`

**src/app/photo/[slug]/page.tsx (NEW):**

This page handles direct links to photos from the homepage context (e.g., `/photo/a1b2c3d4`).

1. Create the file as a Server Component.
2. Define page props:
   ```typescript
   interface PageProps {
     params: Promise<{ slug: string }>;
   }
   ```
3. Implement the page function:
   - Await params to get `slug`
   - Look up the photo: `const photo = await photoRepo.findBySlugPrefix(slug)`
   - If not found, call `notFound()`
   - Fetch the homepage random photos (same as the homepage does: `findRandomFromPublishedAlbums(8)`)
   - Check if the deep-linked photo is already in the random set
   - If NOT in the random set, replace the last photo with the deep-linked photo (so the lightbox can open to it)
   - Render using Header + HomepageClient with `initialPhotoSlug={slug}`
   - Add `export const dynamic = "force-dynamic"` to match homepage behavior

4. Add `generateMetadata` for photo OG tags:
   - Same pattern as album photo metadata: use photo title, EXIF-enriched description, 1200w.webp as OG image
   - For title, use photo.title or fallback to "Photo" (no album context here)
   - Use `summary_large_image` twitter card

**Important implementation notes:**

- Use `notFound()` from `next/navigation` for invalid slugs (per discretion recommendation)
- Use WebP 1200w derivative for all OG images (per research -- AVIF not supported by crawlers)
- Include EXIF data in OG description when available (per discretion -- enriches the preview)
- The homepage photo deep link is inherently approximate since the homepage shows random photos. The deep-linked photo is guaranteed to be in the set, but surrounding photos may differ on each visit. This is acceptable for a portfolio.
  </action>
  <verify>
  Run `npm run typecheck` to confirm no type errors.
  Run `npm run build` to confirm the build succeeds with the new routes.
  Manually verify route resolution: `curl -s http://localhost:3000/albums/{testAlbumId}/photo/{first8chars} | head -20` should return HTML (not 404).
  </verify>
  <done>
- /albums/{id}/photo/{slug} resolves to album page with lightbox pre-opened on the specified photo
- /photo/{slug} resolves to homepage view with lightbox pre-opened on the specified photo
- Both routes have photo-specific OG tags with 1200w WebP image and EXIF-enriched description
- Invalid slugs return 404 via notFound()
- Album photo deep links allow full album navigation in the lightbox
  </done>
  </task>

</tasks>

<verification>
1. `npm run typecheck` passes
2. `npm run build` succeeds
3. Manual: Navigate to `/albums/{albumId}/photo/{first8charsOfPhotoId}` -> lightbox opens on that photo
4. Manual: Navigate to `/photo/{first8charsOfPhotoId}` -> homepage renders with lightbox open on that photo
5. Manual: View page source of album page -> `<meta property="og:title"` contains album title
6. Manual: View page source of album page -> `<meta property="og:image"` contains absolute URL to 1200w.webp
7. Manual: View page source of homepage -> `<meta property="og:title"` contains site name
8. Manual: View page source of photo deep link -> `<meta property="og:image"` contains photo's 1200w.webp
9. Manual: Navigate to `/albums/{id}/photo/zzzzzzzz` (invalid) -> 404 page
</verification>

<success_criteria>

- Deep link pages exist and render correctly for both album and homepage contexts
- OG meta tags present on homepage, album pages, and photo deep link pages
- metadataBase ensures all OG image URLs are absolute
- Album OG uses cover photo (or first photo) as image
- Photo OG includes EXIF data in description when available
- Invalid photo slugs return 404
- All type checks and builds pass
  </success_criteria>

<output>
After completion, create `.planning/phases/14-shareability/14-02-SUMMARY.md`
</output>
